module.exports = [
"[project]/node_modules/@mui/x-internal-gestures/esm/core/ActiveGesturesRegistry.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * ActiveGesturesRegistry - Centralized registry for tracking which gestures are active on elements
 *
 * This singleton class keeps track of all gesture instances that are currently in their active state,
 * allowing both the system and applications to query which gestures are active on specific elements.
 */ /**
 * Type for entries in the active gestures registry
 */ /**
 * Registry that maintains a record of all currently active gestures across elements
 */ __turbopack_context__.s([
    "ActiveGesturesRegistry",
    ()=>ActiveGesturesRegistry
]);
class ActiveGesturesRegistry {
    /** Map of elements to their active gestures */ activeGestures = (()=>new Map())();
    /**
   * Register a gesture as active on an element
   *
   * @param element - The DOM element on which the gesture is active
   * @param gesture - The gesture instance that is active
   */ registerActiveGesture(element, gesture) {
        if (!this.activeGestures.has(element)) {
            this.activeGestures.set(element, new Set());
        }
        const elementGestures = this.activeGestures.get(element);
        const entry = {
            gesture,
            element
        };
        elementGestures.add(entry);
    }
    /**
   * Remove a gesture from the active registry
   *
   * @param element - The DOM element on which the gesture was active
   * @param gesture - The gesture instance to deactivate
   */ unregisterActiveGesture(element, gesture) {
        const elementGestures = this.activeGestures.get(element);
        if (!elementGestures) {
            return;
        }
        // Find and remove the specific gesture entry
        elementGestures.forEach((entry)=>{
            if (entry.gesture === gesture) {
                elementGestures.delete(entry);
            }
        });
        // Remove the element from the map if it no longer has any active gestures
        if (elementGestures.size === 0) {
            this.activeGestures.delete(element);
        }
    }
    /**
   * Get all active gestures for a specific element
   *
   * @param element - The DOM element to query
   * @returns Array of active gesture names
   */ getActiveGestures(element) {
        const elementGestures = this.activeGestures.get(element);
        if (!elementGestures) {
            return {};
        }
        return Array.from(elementGestures).reduce((acc, entry)=>{
            acc[entry.gesture.name] = true;
            return acc;
        }, {});
    }
    /**
   * Check if a specific gesture is active on an element
   *
   * @param element - The DOM element to check
   * @param gesture - The gesture instance to check
   * @returns True if the gesture is active on the element, false otherwise
   */ isGestureActive(element, gesture) {
        const elementGestures = this.activeGestures.get(element);
        if (!elementGestures) {
            return false;
        }
        return Array.from(elementGestures).some((entry)=>entry.gesture === gesture);
    }
    /**
   * Clear all active gestures from the registry
   */ destroy() {
        this.activeGestures.clear();
    }
    /**
   * Clear all active gestures for a specific element
   *
   * @param element - The DOM element to clear
   */ unregisterElement(element) {
        this.activeGestures.delete(element);
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/KeyboardManager.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * KeyboardManager - Manager for keyboard events in the gesture recognition system
 *
 * This class tracks keyboard state:
 * 1. Capturing and tracking all pressed keys
 * 2. Providing methods to check if specific keys are pressed
 */ /**
 * Type definition for keyboard keys
 */ /**
 * Class responsible for tracking keyboard state
 */ __turbopack_context__.s([
    "KeyboardManager",
    ()=>KeyboardManager
]);
class KeyboardManager {
    pressedKeys = (()=>new Set())();
    /**
   * Create a new KeyboardManager instance
   */ constructor(){
        this.initialize();
    }
    /**
   * Initialize the keyboard event listeners
   */ initialize() {
        if ("TURBOPACK compile-time truthy", 1) {
            return;
        }
        //TURBOPACK unreachable
        ;
    }
    /**
   * Handle keydown events
   */ handleKeyDown = (event)=>{
        this.pressedKeys.add(event.key);
    };
    /**
   * Handle keyup events
   */ handleKeyUp = (event)=>{
        this.pressedKeys.delete(event.key);
    };
    /**
   * Clear all pressed keys
   */ clearKeys = ()=>{
        this.pressedKeys.clear();
    };
    /**
   * Check if a set of keys are all currently pressed
   * @param keys The keys to check
   * @returns True if all specified keys are pressed, false otherwise
   */ areKeysPressed(keys) {
        if (!keys || keys.length === 0) {
            return true; // No keys required means the condition is satisfied
        }
        return keys.every((key)=>{
            if (key === 'ControlOrMeta') {
                // May be "deprecated" on types, but it is still the best option for cross-platform detection
                // https://stackoverflow.com/a/71785253/24269134
                return navigator.platform.includes('Mac') ? this.pressedKeys.has('Meta') : this.pressedKeys.has('Control');
            }
            return this.pressedKeys.has(key);
        });
    }
    /**
   * Cleanup method to remove event listeners
   */ destroy() {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        this.clearKeys();
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/PointerManager.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PointerManager",
    ()=>PointerManager
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-ssr] (ecmascript)");
;
class PointerManager {
    /** Root element where pointer events are captured */ /** CSS touch-action property value applied to the root element */ /** Whether to use passive event listeners */ /** Whether to prevent interrupt events like blur or contextmenu */ preventEventInterruption = true;
    /** Map of all currently active pointers by their pointerId */ pointers = (()=>new Map())();
    /** Set of registered gesture handlers that receive pointer events */ gestureHandlers = (()=>new Set())();
    constructor(options){
        this.root = // User provided root element
        options.root ?? // Fallback to document root or body, this fixes shadow DOM scenarios
        document.getRootNode({
            composed: true
        }) ?? // Fallback to document body, for some testing environments
        document.body;
        this.touchAction = options.touchAction || 'auto';
        this.passive = options.passive ?? false;
        this.preventEventInterruption = options.preventEventInterruption ?? true;
        this.setupEventListeners();
    }
    /**
   * Register a handler function to receive pointer events.
   *
   * The handler will be called whenever pointer events occur within the root element.
   * It receives the current map of all active pointers and the original event.
   *
   * @param {Function} handler - Function to receive pointer events and current pointer state
   * @returns {Function} An unregister function that removes this handler when called
   */ registerGestureHandler(handler) {
        this.gestureHandlers.add(handler);
        // Return unregister function
        return ()=>{
            this.gestureHandlers.delete(handler);
        };
    }
    /**
   * Get a copy of the current active pointers map.
   *
   * Returns a new Map containing all currently active pointers.
   * Modifying the returned map will not affect the internal pointers state.
   *
   * @returns A new Map containing all active pointers
   */ getPointers() {
        return new Map(this.pointers);
    }
    /**
   * Set up event listeners for pointer events on the root element.
   *
   * This method attaches all necessary event listeners and configures
   * the CSS touch-action property on the root element.
   */ setupEventListeners() {
        // Set touch-action CSS property
        if (this.touchAction !== 'auto') {
            this.root.style.touchAction = this.touchAction;
        }
        // Add event listeners
        this.root.addEventListener('pointerdown', this.handlePointerEvent, {
            passive: this.passive
        });
        this.root.addEventListener('pointermove', this.handlePointerEvent, {
            passive: this.passive
        });
        this.root.addEventListener('pointerup', this.handlePointerEvent, {
            passive: this.passive
        });
        this.root.addEventListener('pointercancel', this.handlePointerEvent, {
            passive: this.passive
        });
        // @ts-expect-error, forceCancel is not a standard event, but used for custom handling
        this.root.addEventListener('forceCancel', this.handlePointerEvent, {
            passive: this.passive
        });
        // Add blur and contextmenu event listeners to interrupt all gestures
        this.root.addEventListener('blur', this.handleInterruptEvents);
        this.root.addEventListener('contextmenu', this.handleInterruptEvents);
    }
    /**
   * Handle events that should interrupt all gestures.
   * This clears all active pointers and notifies handlers with a pointercancel-like event.
   *
   * @param event - The event that triggered the interruption (blur or contextmenu)
   */ handleInterruptEvents = (event)=>{
        if (this.preventEventInterruption && 'pointerType' in event && event.pointerType === 'touch') {
            event.preventDefault();
            return;
        }
        // Create a synthetic pointer cancel event
        const cancelEvent = new PointerEvent('forceCancel', {
            bubbles: false,
            cancelable: false
        });
        const firstPointer = this.pointers.values().next().value;
        if (this.pointers.size > 0 && firstPointer) {
            // If there are active pointers, use the first one as a template for coordinates
            // Update the synthetic event with the pointer's coordinates
            Object.defineProperties(cancelEvent, {
                clientX: {
                    value: firstPointer.clientX
                },
                clientY: {
                    value: firstPointer.clientY
                },
                pointerId: {
                    value: firstPointer.pointerId
                },
                pointerType: {
                    value: firstPointer.pointerType
                }
            });
            // Force update of all pointers to have type 'forceCancel'
            for (const [pointerId, pointer] of this.pointers.entries()){
                const updatedPointer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, pointer, {
                    type: 'forceCancel'
                });
                this.pointers.set(pointerId, updatedPointer);
            }
        }
        // Notify all handlers about the interruption
        this.notifyHandlers(cancelEvent);
        // Clear all pointers
        this.pointers.clear();
    };
    /**
   * Event handler for all pointer events.
   *
   * This method:
   * 1. Updates the internal pointers map based on the event type
   * 2. Manages pointer capture for tracking pointers outside the root element
   * 3. Notifies all registered handlers with the current state
   *
   * @param event - The original pointer event from the browser
   */ handlePointerEvent = (event)=>{
        const { type, pointerId } = event;
        // Create or update pointer data
        if (type === 'pointerdown' || type === 'pointermove') {
            this.pointers.set(pointerId, this.createPointerData(event));
        } else if (type === 'pointerup' || type === 'pointercancel' || type === 'forceCancel') {
            // Update one last time before removing
            this.pointers.set(pointerId, this.createPointerData(event));
            // Notify handlers with current state
            this.notifyHandlers(event);
            // Then remove the pointer
            this.pointers.delete(pointerId);
            return;
        }
        this.notifyHandlers(event);
    };
    /**
   * Notify all registered gesture handlers about a pointer event.
   *
   * Each handler receives the current map of active pointers and the original event.
   *
   * @param event - The original pointer event that triggered this notification
   */ notifyHandlers(event) {
        this.gestureHandlers.forEach((handler)=>handler(this.pointers, event));
    }
    /**
   * Create a normalized PointerData object from a browser PointerEvent.
   *
   * This method extracts all relevant information from the original event
   * and formats it in a consistent way for gesture recognizers to use.
   *
   * @param event - The original browser pointer event
   * @returns A new PointerData object representing this pointer
   */ createPointerData(event) {
        return {
            pointerId: event.pointerId,
            clientX: event.clientX,
            clientY: event.clientY,
            pageX: event.pageX,
            pageY: event.pageY,
            target: event.target,
            timeStamp: event.timeStamp,
            type: event.type,
            isPrimary: event.isPrimary,
            pressure: event.pressure,
            width: event.width,
            height: event.height,
            pointerType: event.pointerType,
            srcEvent: event
        };
    }
    /**
   * Clean up all event listeners and reset the PointerManager state.
   *
   * This method should be called when the PointerManager is no longer needed
   * to prevent memory leaks. It removes all event listeners, clears the
   * internal state, and resets the singleton instance.
   */ destroy() {
        this.root.removeEventListener('pointerdown', this.handlePointerEvent);
        this.root.removeEventListener('pointermove', this.handlePointerEvent);
        this.root.removeEventListener('pointerup', this.handlePointerEvent);
        this.root.removeEventListener('pointercancel', this.handlePointerEvent);
        // @ts-expect-error, forceCancel is not a standard event, but used for custom handling
        this.root.removeEventListener('forceCancel', this.handlePointerEvent);
        this.root.removeEventListener('blur', this.handleInterruptEvents);
        this.root.removeEventListener('contextmenu', this.handleInterruptEvents);
        this.pointers.clear();
        this.gestureHandlers.clear();
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/GestureManager.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GestureManager",
    ()=>GestureManager
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$ActiveGesturesRegistry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/ActiveGesturesRegistry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$KeyboardManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/KeyboardManager.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/PointerManager.js [app-ssr] (ecmascript)");
;
;
;
class GestureManager {
    /** Repository of gesture templates that can be cloned for specific elements */ gestureTemplates = (()=>new Map())();
    /** Maps DOM elements to their active gesture instances */ elementGestureMap = (()=>new Map())();
    activeGesturesRegistry = (()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$ActiveGesturesRegistry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ActiveGesturesRegistry"]())();
    keyboardManager = (()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$KeyboardManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["KeyboardManager"]())();
    /**
   * Create a new GestureManager instance to coordinate gesture recognition
   *
   * @param options - Configuration options for the gesture manager
   */ constructor(options){
        // Initialize the PointerManager
        this.pointerManager = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PointerManager"]({
            root: options.root,
            touchAction: options.touchAction,
            passive: options.passive
        });
        // Add initial gestures as templates if provided
        if (options.gestures && options.gestures.length > 0) {
            options.gestures.forEach((gesture)=>{
                this.addGestureTemplate(gesture);
            });
        }
    }
    /**
   * Add a gesture template to the manager's template registry.
   * Templates serve as prototypes that can be cloned for individual elements.
   *
   * @param gesture - The gesture instance to use as a template
   */ addGestureTemplate(gesture) {
        if (this.gestureTemplates.has(gesture.name)) {
            console.warn(`Gesture template with name "${gesture.name}" already exists. It will be overwritten.`);
        }
        this.gestureTemplates.set(gesture.name, gesture);
    }
    /**
   * Updates the options for a specific gesture on a given element and emits a change event.
   *
   * @param gestureName - Name of the gesture whose options should be updated
   * @param element - The DOM element where the gesture is attached
   * @param options - New options to apply to the gesture
   * @returns True if the options were successfully updated, false if the gesture wasn't found
   *
   * @example
   * ```typescript
   * // Update pan gesture sensitivity on the fly
   * manager.setGestureOptions('pan', element, { threshold: 5 });
   * ```
   */ setGestureOptions(gestureName, element, options) {
        const elementGestures = this.elementGestureMap.get(element);
        if (!elementGestures || !elementGestures.has(gestureName)) {
            console.error(`Gesture "${gestureName}" not found on the provided element.`);
            return;
        }
        const event = new CustomEvent(`${gestureName}ChangeOptions`, {
            detail: options,
            bubbles: false,
            cancelable: false,
            composed: false
        });
        element.dispatchEvent(event);
    }
    /**
   * Updates the state for a specific gesture on a given element and emits a change event.
   *
   * @param gestureName - Name of the gesture whose state should be updated
   * @param element - The DOM element where the gesture is attached
   * @param state - New state to apply to the gesture
   * @returns True if the state was successfully updated, false if the gesture wasn't found
   *
   * @example
   * ```typescript
   * // Update total delta for a turnWheel gesture
   * manager.setGestureState('turnWheel', element, { totalDeltaX: 10 });
   * ```
   */ setGestureState(gestureName, element, state) {
        const elementGestures = this.elementGestureMap.get(element);
        if (!elementGestures || !elementGestures.has(gestureName)) {
            console.error(`Gesture "${gestureName}" not found on the provided element.`);
            return;
        }
        const event = new CustomEvent(`${gestureName}ChangeState`, {
            detail: state,
            bubbles: false,
            cancelable: false,
            composed: false
        });
        element.dispatchEvent(event);
    }
    /**
   * Register an element to recognize one or more gestures.
   *
   * This method clones the specified gesture template(s) and creates
   * gesture recognizer instance(s) specifically for the provided element.
   * The element is returned with enhanced TypeScript typing for gesture events.
   *
   * @param gestureNames - Name(s) of the gesture(s) to register (must match template names)
   * @param element - The DOM element to attach the gesture(s) to
   * @param options - Optional map of gesture-specific options to override when registering
   * @returns The same element with properly typed event listeners
   *
   * @example
   * ```typescript
   * // Register multiple gestures
   * const element = manager.registerElement(['pan', 'pinch'], myDiv);
   *
   * // Register a single gesture
   * const draggable = manager.registerElement('pan', dragHandle);
   *
   * // Register with customized options for each gesture
   * const customElement = manager.registerElement(
   *   ['pan', 'pinch', 'rotate'],
   *   myElement,
   *   {
   *     pan: { threshold: 20, direction: ['left', 'right'] },
   *     pinch: { threshold: 0.1 }
   *   }
   * );
   * ```
   */ registerElement(gestureNames, element, options) {
        // Handle array of gesture names
        if (!Array.isArray(gestureNames)) {
            gestureNames = [
                gestureNames
            ];
        }
        gestureNames.forEach((name)=>{
            const gestureOptions = options?.[name];
            this.registerSingleGesture(name, element, gestureOptions);
        });
        return element;
    }
    /**
   * Internal method to register a single gesture on an element.
   *
   * @param gestureName - Name of the gesture to register
   * @param element - DOM element to attach the gesture to
   * @param options - Optional options to override the gesture template configuration
   * @returns True if the registration was successful, false otherwise
   */ registerSingleGesture(gestureName, element, options) {
        // Find the gesture template
        const gestureTemplate = this.gestureTemplates.get(gestureName);
        if (!gestureTemplate) {
            console.error(`Gesture template "${gestureName}" not found.`);
            return false;
        }
        // Create element's gesture map if it doesn't exist
        if (!this.elementGestureMap.has(element)) {
            this.elementGestureMap.set(element, new Map());
        }
        // Check if this element already has this gesture registered
        const elementGestures = this.elementGestureMap.get(element);
        if (elementGestures.has(gestureName)) {
            console.warn(`Element already has gesture "${gestureName}" registered. It will be replaced.`);
            // Unregister the existing gesture first
            this.unregisterElement(gestureName, element);
        }
        // Clone the gesture template and create a new instance with optional overrides
        // This allows each element to have its own state, event listeners, and configuration
        const gestureInstance = gestureTemplate.clone(options);
        gestureInstance.init(element, this.pointerManager, this.activeGesturesRegistry, this.keyboardManager);
        // Store the gesture in the element's gesture map
        elementGestures.set(gestureName, gestureInstance);
        return true;
    }
    /**
   * Unregister a specific gesture from an element.
   * This removes the gesture recognizer and stops event emission for that gesture.
   *
   * @param gestureName - Name of the gesture to unregister
   * @param element - The DOM element to remove the gesture from
   * @returns True if the gesture was found and removed, false otherwise
   */ unregisterElement(gestureName, element) {
        const elementGestures = this.elementGestureMap.get(element);
        if (!elementGestures || !elementGestures.has(gestureName)) {
            return false;
        }
        // Destroy the gesture instance
        const gesture = elementGestures.get(gestureName);
        gesture.destroy();
        // Remove from the map
        elementGestures.delete(gestureName);
        this.activeGesturesRegistry.unregisterElement(element);
        // Remove the element from the map if it no longer has any gestures
        if (elementGestures.size === 0) {
            this.elementGestureMap.delete(element);
        }
        return true;
    }
    /**
   * Unregister all gestures from an element.
   * Completely removes the element from the gesture system.
   *
   * @param element - The DOM element to remove all gestures from
   */ unregisterAllGestures(element) {
        const elementGestures = this.elementGestureMap.get(element);
        if (elementGestures) {
            // Unregister all gestures for this element
            for (const [, gesture] of elementGestures){
                gesture.destroy();
                this.activeGesturesRegistry.unregisterElement(element);
            }
            // Clear the map
            this.elementGestureMap.delete(element);
        }
    }
    /**
   * Clean up all gestures and event listeners.
   * Call this method when the GestureManager is no longer needed to prevent memory leaks.
   */ destroy() {
        // Unregister all element gestures
        for (const [element] of this.elementGestureMap){
            this.unregisterAllGestures(element);
        }
        // Clear all templates
        this.gestureTemplates.clear();
        this.elementGestureMap.clear();
        this.activeGesturesRegistry.destroy();
        this.keyboardManager.destroy();
        this.pointerManager.destroy();
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/eventList.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "eventList",
    ()=>eventList
]);
const eventList = {
    abort: true,
    animationcancel: true,
    animationend: true,
    animationiteration: true,
    animationstart: true,
    auxclick: true,
    beforeinput: true,
    beforetoggle: true,
    blur: true,
    cancel: true,
    canplay: true,
    canplaythrough: true,
    change: true,
    click: true,
    close: true,
    compositionend: true,
    compositionstart: true,
    compositionupdate: true,
    contextlost: true,
    contextmenu: true,
    contextrestored: true,
    copy: true,
    cuechange: true,
    cut: true,
    dblclick: true,
    drag: true,
    dragend: true,
    dragenter: true,
    dragleave: true,
    dragover: true,
    dragstart: true,
    drop: true,
    durationchange: true,
    emptied: true,
    ended: true,
    error: true,
    focus: true,
    focusin: true,
    focusout: true,
    formdata: true,
    gotpointercapture: true,
    input: true,
    invalid: true,
    keydown: true,
    keypress: true,
    keyup: true,
    load: true,
    loadeddata: true,
    loadedmetadata: true,
    loadstart: true,
    lostpointercapture: true,
    mousedown: true,
    mouseenter: true,
    mouseleave: true,
    mousemove: true,
    mouseout: true,
    mouseover: true,
    mouseup: true,
    paste: true,
    pause: true,
    play: true,
    playing: true,
    pointercancel: true,
    pointerdown: true,
    pointerenter: true,
    pointerleave: true,
    pointermove: true,
    pointerout: true,
    pointerover: true,
    pointerup: true,
    progress: true,
    ratechange: true,
    reset: true,
    resize: true,
    scroll: true,
    scrollend: true,
    securitypolicyviolation: true,
    seeked: true,
    seeking: true,
    select: true,
    selectionchange: true,
    selectstart: true,
    slotchange: true,
    stalled: true,
    submit: true,
    suspend: true,
    timeupdate: true,
    toggle: true,
    touchcancel: true,
    touchend: true,
    touchmove: true,
    touchstart: true,
    transitioncancel: true,
    transitionend: true,
    transitionrun: true,
    transitionstart: true,
    volumechange: true,
    waiting: true,
    webkitanimationend: true,
    webkitanimationiteration: true,
    webkitanimationstart: true,
    webkittransitionend: true,
    wheel: true,
    beforematch: true,
    pointerrawupdate: true
};
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/Gesture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Gesture",
    ()=>Gesture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-ssr] (ecmascript)");
/**
 * Base Gesture module that provides common functionality for all gesture implementations
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$eventList$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/eventList.js [app-ssr] (ecmascript)");
;
;
class Gesture {
    /** Unique name identifying this gesture type */ /** Whether to prevent default browser action for gesture events */ /** Whether to stop propagation of gesture events */ /**
   * List of gesture names that should prevent this gesture from activating when they are active.
   */ /**
   * Array of keyboard keys that must be pressed for the gesture to be recognized.
   */ /**
   * KeyboardManager instance for tracking key presses
   */ /**
   * List of pointer types that can trigger this gesture.
   * If undefined, all pointer types are allowed.
   */ /**
   * Pointer mode-specific configuration overrides.
   */ /**
   * User-mutable data object for sharing state between gesture events
   * This object is included in all events emitted by this gesture
   */ customData = {};
    /** Reference to the singleton PointerManager instance */ /** Reference to the singleton ActiveGesturesRegistry instance */ /** The DOM element this gesture is attached to */ /** Stores the active gesture state */ /** @internal For types. If false enables phases (xStart, x, xEnd) */ /** @internal For types. The event type this gesture is associated with */ /** @internal For types. The options type for this gesture */ /** @internal For types. The options that can be changed at runtime */ /** @internal For types. The state that can be changed at runtime */ /**
   * Create a new gesture instance with the specified options
   *
   * @param options - Configuration options for this gesture
   */ constructor(options){
        if (!options || !options.name) {
            throw new Error('Gesture must be initialized with a valid name.');
        }
        if (options.name in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$eventList$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["eventList"]) {
            throw new Error(`Gesture can't be created with a native event name. Tried to use "${options.name}". Please use a custom name instead.`);
        }
        this.name = options.name;
        this.preventDefault = options.preventDefault ?? false;
        this.stopPropagation = options.stopPropagation ?? false;
        this.preventIf = options.preventIf ?? [];
        this.requiredKeys = options.requiredKeys ?? [];
        this.pointerMode = options.pointerMode ?? [];
        this.pointerOptions = options.pointerOptions ?? {};
    }
    /**
   * Initialize the gesture by acquiring the pointer manager and gestures registry
   * Must be called before the gesture can be used
   */ init(element, pointerManager, gestureRegistry, keyboardManager) {
        this.element = element;
        this.pointerManager = pointerManager;
        this.gesturesRegistry = gestureRegistry;
        this.keyboardManager = keyboardManager;
        const changeOptionsEventName = `${this.name}ChangeOptions`;
        this.element.addEventListener(changeOptionsEventName, this.handleOptionsChange);
        const changeStateEventName = `${this.name}ChangeState`;
        this.element.addEventListener(changeStateEventName, this.handleStateChange);
    }
    /**
   * Handle option change events
   * @param event Custom event with new options in the detail property
   */ handleOptionsChange = (event)=>{
        if (event && event.detail) {
            this.updateOptions(event.detail);
        }
    };
    /**
   * Update the gesture options with new values
   * @param options Object containing properties to update
   */ updateOptions(options) {
        // Update common options
        this.preventDefault = options.preventDefault ?? this.preventDefault;
        this.stopPropagation = options.stopPropagation ?? this.stopPropagation;
        this.preventIf = options.preventIf ?? this.preventIf;
        this.requiredKeys = options.requiredKeys ?? this.requiredKeys;
        this.pointerMode = options.pointerMode ?? this.pointerMode;
        this.pointerOptions = options.pointerOptions ?? this.pointerOptions;
    }
    /**
   * Get the default configuration for the pointer specific options.
   * Change this function in child classes to provide different defaults.
   */ getBaseConfig() {
        return {
            requiredKeys: this.requiredKeys
        };
    }
    /**
   * Get the effective configuration for a specific pointer mode.
   * This merges the base configuration with pointer mode-specific overrides.
   *
   * @param pointerType - The pointer type to get configuration for
   * @returns The effective configuration object
   */ getEffectiveConfig(pointerType, baseConfig) {
        if (pointerType !== 'mouse' && pointerType !== 'touch' && pointerType !== 'pen') {
            // Unknown pointer type, return base config
            return baseConfig;
        }
        // Apply pointer mode-specific overrides
        const pointerModeOverrides = this.pointerOptions[pointerType];
        if (pointerModeOverrides) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, baseConfig, pointerModeOverrides);
        }
        return baseConfig;
    }
    /**
   * Handle state change events
   * @param event Custom event with new state values in the detail property
   */ handleStateChange = (event)=>{
        if (event && event.detail) {
            this.updateState(event.detail);
        }
    };
    /**
   * Update the gesture state with new values
   * @param stateChanges Object containing state properties to update
   */ updateState(stateChanges) {
        // This is a base implementation - concrete gesture classes should override
        // to handle specific state updates based on their state structure
        Object.assign(this.state, stateChanges);
    }
    /**
   * Create a deep clone of this gesture for a new element
   *
   * @param overrides - Optional configuration options that override the defaults
   * @returns A new instance of this gesture with the same configuration and any overrides applied
   */ /**
   * Check if the event's target is or is contained within any of our registered elements
   *
   * @param event - The browser event to check
   * @returns The matching element or null if no match is found
   */ getTargetElement(event) {
        if (this.isActive || this.element === event.target || 'contains' in this.element && this.element.contains(event.target) || 'getRootNode' in this.element && this.element.getRootNode() instanceof ShadowRoot && event.composedPath().includes(this.element)) {
            return this.element;
        }
        return null;
    }
    /** Whether the gesture is currently active */ set isActive(isActive) {
        if (isActive) {
            this.gesturesRegistry.registerActiveGesture(this.element, this);
        } else {
            this.gesturesRegistry.unregisterActiveGesture(this.element, this);
        }
    }
    /** Whether the gesture is currently active */ get isActive() {
        return this.gesturesRegistry.isGestureActive(this.element, this) ?? false;
    }
    /**
   * Checks if this gesture should be prevented from activating.
   *
   * @param element - The DOM element to check against
   * @param pointerType - The type of pointer triggering the gesture
   * @returns true if the gesture should be prevented, false otherwise
   */ shouldPreventGesture(element, pointerType) {
        // Get effective configuration for this pointer type
        const effectiveConfig = this.getEffectiveConfig(pointerType, this.getBaseConfig());
        // First check if required keyboard keys are pressed
        if (!this.keyboardManager.areKeysPressed(effectiveConfig.requiredKeys)) {
            return true; // Prevent the gesture if required keys are not pressed
        }
        if (this.preventIf.length === 0) {
            return false; // No prevention rules, allow the gesture
        }
        const activeGestures = this.gesturesRegistry.getActiveGestures(element);
        // Check if any of the gestures that would prevent this one are active
        return this.preventIf.some((gestureName)=>activeGestures[gestureName]);
    }
    /**
   * Checks if the given pointer type is allowed for this gesture based on the pointerMode setting.
   *
   * @param pointerType - The type of pointer to check.
   * @returns true if the pointer type is allowed, false otherwise.
   */ isPointerTypeAllowed(pointerType) {
        // If no pointer mode is specified, all pointer types are allowed
        if (!this.pointerMode || this.pointerMode.length === 0) {
            return true;
        }
        // Check if the pointer type is in the allowed types list
        return this.pointerMode.includes(pointerType);
    }
    /**
   * Clean up the gesture and unregister any listeners
   * Call this method when the gesture is no longer needed to prevent memory leaks
   */ destroy() {
        const changeOptionsEventName = `${this.name}ChangeOptions`;
        this.element.removeEventListener(changeOptionsEventName, this.handleOptionsChange);
        const changeStateEventName = `${this.name}ChangeState`;
        this.element.removeEventListener(changeStateEventName, this.handleStateChange);
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/PointerGesture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PointerGesture",
    ()=>PointerGesture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$Gesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/Gesture.js [app-ssr] (ecmascript)");
;
class PointerGesture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$Gesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Gesture"] {
    /** Function to unregister from the PointerManager when destroying this gesture */ unregisterHandler = null;
    /** The original target element when the gesture began, used to prevent limbo state if target is removed */ originalTarget = null;
    /**
   * Minimum number of simultaneous pointers required to activate the gesture.
   * The gesture will not start until at least this many pointers are active.
   */ /**
   * Maximum number of simultaneous pointers allowed for this gesture.
   * If more than this many pointers are detected, the gesture may be canceled.
   */ constructor(options){
        super(options);
        this.minPointers = options.minPointers ?? 1;
        this.maxPointers = options.maxPointers ?? Infinity;
    }
    init(element, pointerManager, gestureRegistry, keyboardManager) {
        super.init(element, pointerManager, gestureRegistry, keyboardManager);
        this.unregisterHandler = this.pointerManager.registerGestureHandler(this.handlePointerEvent);
    }
    updateOptions(options) {
        super.updateOptions(options);
        this.minPointers = options.minPointers ?? this.minPointers;
        this.maxPointers = options.maxPointers ?? this.maxPointers;
    }
    getBaseConfig() {
        return {
            requiredKeys: this.requiredKeys,
            minPointers: this.minPointers,
            maxPointers: this.maxPointers
        };
    }
    isWithinPointerCount(pointers, pointerMode) {
        const config = this.getEffectiveConfig(pointerMode, this.getBaseConfig());
        return pointers.length >= config.minPointers && pointers.length <= config.maxPointers;
    }
    /**
   * Handler for pointer events from the PointerManager.
   * Concrete gesture implementations must override this method to provide
   * gesture-specific logic for recognizing and tracking the gesture.
   *
   * @param pointers - Map of active pointers by pointer ID
   * @param event - The original pointer event from the browser
   */ /**
   * Calculate the target element for the gesture based on the active pointers.
   *
   * It takes into account the original target element.
   *
   * @param pointers - Map of active pointers by pointer ID
   * @param calculatedTarget - The target element calculated from getTargetElement
   * @returns A list of relevant pointers for this gesture
   */ getRelevantPointers(pointers, calculatedTarget) {
        return pointers.filter((pointer)=>this.isPointerTypeAllowed(pointer.pointerType) && (calculatedTarget === pointer.target || pointer.target === this.originalTarget || calculatedTarget === this.originalTarget || 'contains' in calculatedTarget && calculatedTarget.contains(pointer.target)) || 'getRootNode' in calculatedTarget && calculatedTarget.getRootNode() instanceof ShadowRoot && pointer.srcEvent.composedPath().includes(calculatedTarget));
    }
    destroy() {
        if (this.unregisterHandler) {
            this.unregisterHandler();
            this.unregisterHandler = null;
        }
        super.destroy();
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/calculateCentroid.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Calculate the centroid (average position) of multiple pointers
 */ __turbopack_context__.s([
    "calculateCentroid",
    ()=>calculateCentroid
]);
function calculateCentroid(pointers) {
    if (pointers.length === 0) {
        return {
            x: 0,
            y: 0
        };
    }
    const sum = pointers.reduce((acc, pointer)=>{
        acc.x += pointer.clientX;
        acc.y += pointer.clientY;
        return acc;
    }, {
        x: 0,
        y: 0
    });
    return {
        x: sum.x / pointers.length,
        y: sum.y / pointers.length
    };
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/createEventName.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Creates the event name for a specific gesture and phase
 */ __turbopack_context__.s([
    "createEventName",
    ()=>createEventName
]);
function createEventName(gesture, phase) {
    return `${gesture}${phase === 'ongoing' ? '' : phase.charAt(0).toUpperCase() + phase.slice(1)}`;
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/MoveGesture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MoveGesture",
    ()=>MoveGesture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-ssr] (ecmascript)");
/**
 * MoveGesture - Detects when a pointer enters, moves within, and leaves an element
 *
 * This gesture tracks pointer movements over an element, firing events when:
 * - A pointer enters the element (start)
 * - A pointer moves within the element (ongoing)
 * - A pointer leaves the element (end)
 *
 * Unlike other gestures which often require specific actions to trigger,
 * the move gesture fires automatically when pointers interact with the target element.
 *
 * This gesture only works with mouse pointers, not touch or pen.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/PointerGesture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/calculateCentroid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/createEventName.js [app-ssr] (ecmascript)");
;
;
;
class MoveGesture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PointerGesture"] {
    state = {
        lastPosition: null
    };
    /**
   * Movement threshold in pixels that must be exceeded before the gesture activates.
   * Higher values reduce false positive gesture detection for small movements.
   */ constructor(options){
        super(options);
        this.threshold = options.threshold || 0;
    }
    clone(overrides) {
        return new MoveGesture((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            name: this.name,
            preventDefault: this.preventDefault,
            stopPropagation: this.stopPropagation,
            threshold: this.threshold,
            minPointers: this.minPointers,
            maxPointers: this.maxPointers,
            requiredKeys: [
                ...this.requiredKeys
            ],
            pointerMode: [
                ...this.pointerMode
            ],
            preventIf: [
                ...this.preventIf
            ],
            pointerOptions: structuredClone(this.pointerOptions)
        }, overrides));
    }
    init(element, pointerManager, gestureRegistry, keyboardManager) {
        super.init(element, pointerManager, gestureRegistry, keyboardManager);
        // Add event listeners for entering and leaving elements
        // These are different from pointer events handled by PointerManager
        // @ts-expect-error, PointerEvent is correct.
        this.element.addEventListener('pointerenter', this.handleElementEnter);
        // @ts-expect-error, PointerEvent is correct.
        this.element.addEventListener('pointerleave', this.handleElementLeave);
    }
    destroy() {
        // Remove event listeners using the same function references
        // @ts-expect-error, PointerEvent is correct.
        this.element.removeEventListener('pointerenter', this.handleElementEnter);
        // @ts-expect-error, PointerEvent is correct.
        this.element.removeEventListener('pointerleave', this.handleElementLeave);
        this.resetState();
        super.destroy();
    }
    updateOptions(options) {
        // Call parent method to handle common options
        super.updateOptions(options);
    }
    resetState() {
        this.isActive = false;
        this.state = {
            lastPosition: null
        };
    }
    /**
   * Handle pointer enter events for a specific element
   * @param event The original pointer event
   */ handleElementEnter = (event)=>{
        if (event.pointerType !== 'mouse' && event.pointerType !== 'pen') {
            return;
        }
        // Get pointers from the PointerManager
        const pointers = this.pointerManager.getPointers() || new Map();
        const pointersArray = Array.from(pointers.values());
        // Only activate if we're within pointer count constraints
        if (this.isWithinPointerCount(pointersArray, event.pointerType)) {
            this.isActive = true;
            const currentPosition = {
                x: event.clientX,
                y: event.clientY
            };
            this.state.lastPosition = currentPosition;
            // Emit start event
            this.emitMoveEvent(this.element, 'start', pointersArray, event);
            this.emitMoveEvent(this.element, 'ongoing', pointersArray, event);
        }
    };
    /**
   * Handle pointer leave events for a specific element
   * @param event The original pointer event
   */ handleElementLeave = (event)=>{
        if (event.pointerType !== 'mouse' && event.pointerType !== 'pen') {
            return;
        }
        if (!this.isActive) {
            return;
        }
        // Get pointers from the PointerManager
        const pointers = this.pointerManager.getPointers() || new Map();
        const pointersArray = Array.from(pointers.values());
        // Emit end event and reset state
        this.emitMoveEvent(this.element, 'end', pointersArray, event);
        this.resetState();
    };
    /**
   * Handle pointer events for the move gesture (only handles move events now)
   * @param pointers Map of active pointers
   * @param event The original pointer event
   */ handlePointerEvent = (pointers, event)=>{
        if (event.type !== 'pointermove' || event.pointerType !== 'mouse' && event.pointerType !== 'pen') {
            return;
        }
        if (this.preventDefault) {
            event.preventDefault();
        }
        if (this.stopPropagation) {
            event.stopPropagation();
        }
        const pointersArray = Array.from(pointers.values());
        // Find which element (if any) is being targeted
        const targetElement = this.getTargetElement(event);
        if (!targetElement) {
            return;
        }
        if (!this.isWithinPointerCount(pointersArray, event.pointerType)) {
            return;
        }
        if (this.shouldPreventGesture(targetElement, event.pointerType)) {
            if (!this.isActive) {
                return;
            }
            this.resetState();
            this.emitMoveEvent(targetElement, 'end', pointersArray, event);
            return;
        }
        // Update position
        const currentPosition = {
            x: event.clientX,
            y: event.clientY
        };
        this.state.lastPosition = currentPosition;
        if (!this.isActive) {
            this.isActive = true;
            this.emitMoveEvent(targetElement, 'start', pointersArray, event);
        }
        // Emit ongoing event
        this.emitMoveEvent(targetElement, 'ongoing', pointersArray, event);
    };
    /**
   * Emit move-specific events
   * @param element The DOM element the event is related to
   * @param phase The current phase of the gesture (start, ongoing, end)
   * @param pointers Array of active pointers
   * @param event The original pointer event
   */ emitMoveEvent(element, phase, pointers, event) {
        const currentPosition = this.state.lastPosition || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateCentroid"])(pointers);
        // Get list of active gestures
        const activeGestures = this.gesturesRegistry.getActiveGestures(element);
        // Create custom event data
        const customEventData = {
            gestureName: this.name,
            centroid: currentPosition,
            target: event.target,
            srcEvent: event,
            phase,
            pointers,
            timeStamp: event.timeStamp,
            activeGestures,
            customData: this.customData
        };
        // Event names to trigger
        const eventName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, phase);
        // Dispatch custom events on the element
        const domEvent = new CustomEvent(eventName, {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: customEventData
        });
        element.dispatchEvent(domEvent);
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/getDirection.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getDirection",
    ()=>getDirection
]);
const MAIN_THRESHOLD = 0.00001;
const ANGLE_THRESHOLD = 0.00001;
const SECONDARY_THRESHOLD = 0.15;
function getDirection(previous, current) {
    const deltaX = current.x - previous.x;
    const deltaY = current.y - previous.y;
    const direction = {
        vertical: null,
        horizontal: null,
        mainAxis: null
    };
    const isDiagonal = isDiagonalMovement(current, previous);
    const mainMovement = Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical';
    // eslint-disable-next-line no-nested-ternary
    const horizontalThreshold = isDiagonal ? MAIN_THRESHOLD : mainMovement === 'horizontal' ? MAIN_THRESHOLD : SECONDARY_THRESHOLD;
    // eslint-disable-next-line no-nested-ternary
    const verticalThreshold = isDiagonal ? MAIN_THRESHOLD : mainMovement === 'horizontal' ? SECONDARY_THRESHOLD : MAIN_THRESHOLD;
    // Set horizontal direction if there's a significant movement horizontally
    if (Math.abs(deltaX) > horizontalThreshold) {
        // Small threshold to avoid noise
        direction.horizontal = deltaX > 0 ? 'right' : 'left';
    }
    // Set vertical direction if there's a significant movement vertically
    if (Math.abs(deltaY) > verticalThreshold) {
        // Small threshold to avoid noise
        direction.vertical = deltaY > 0 ? 'down' : 'up';
    }
    direction.mainAxis = isDiagonal ? 'diagonal' : mainMovement;
    return direction;
}
function isDiagonalMovement(previous, current) {
    const deltaX = current.x - previous.x;
    const deltaY = current.y - previous.y;
    // Calculate the angle of movement
    const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
    // Check if the angle is within the diagonal range
    return angle >= -45 + ANGLE_THRESHOLD && angle <= -22.5 + ANGLE_THRESHOLD || angle >= 22.5 + ANGLE_THRESHOLD && angle <= 45 + ANGLE_THRESHOLD || angle >= 135 + ANGLE_THRESHOLD && angle <= 157.5 + ANGLE_THRESHOLD || angle >= -157.5 + ANGLE_THRESHOLD && angle <= -135 + ANGLE_THRESHOLD;
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/isDirectionAllowed.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Check if a direction matches one of the allowed directions
 */ __turbopack_context__.s([
    "isDirectionAllowed",
    ()=>isDirectionAllowed
]);
function isDirectionAllowed(direction, allowedDirections) {
    if (!direction.vertical && !direction.horizontal) {
        return false;
    }
    if (allowedDirections.length === 0) {
        return true;
    }
    // Check if the vertical direction is allowed (if it exists)
    const verticalAllowed = direction.vertical === null || allowedDirections.includes(direction.vertical);
    // Check if the horizontal direction is allowed (if it exists)
    const horizontalAllowed = direction.horizontal === null || allowedDirections.includes(direction.horizontal);
    // Both directions must be allowed
    return verticalAllowed && horizontalAllowed;
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/PanGesture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PanGesture",
    ()=>PanGesture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-ssr] (ecmascript)");
/**
 * PanGesture - Detects panning (dragging) movements
 *
 * This gesture tracks pointer dragging movements across elements, firing events when:
 * - The drag movement begins and passes the threshold distance (start)
 * - The drag movement continues (ongoing)
 * - The drag movement ends (end)
 *
 * The gesture can be configured to recognize movement only in specific directions.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/PointerGesture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/calculateCentroid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/createEventName.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$getDirection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/getDirection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$isDirectionAllowed$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/isDirectionAllowed.js [app-ssr] (ecmascript)");
;
;
;
class PanGesture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PointerGesture"] {
    state = (()=>({
            startPointers: new Map(),
            startCentroid: null,
            lastCentroid: null,
            movementThresholdReached: false,
            totalDeltaX: 0,
            totalDeltaY: 0,
            activeDeltaX: 0,
            activeDeltaY: 0,
            lastDirection: {
                vertical: null,
                horizontal: null,
                mainAxis: null
            },
            lastDeltas: null
        }))();
    /**
   * Movement threshold in pixels that must be exceeded before the gesture activates.
   * Higher values reduce false positive gesture detection for small movements.
   */ /**
   * Allowed directions for the pan gesture
   * Default allows all directions
   */ constructor(options){
        super(options);
        this.direction = options.direction || [
            'up',
            'down',
            'left',
            'right'
        ];
        this.threshold = options.threshold || 0;
    }
    clone(overrides) {
        return new PanGesture((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            name: this.name,
            preventDefault: this.preventDefault,
            stopPropagation: this.stopPropagation,
            threshold: this.threshold,
            minPointers: this.minPointers,
            maxPointers: this.maxPointers,
            direction: [
                ...this.direction
            ],
            requiredKeys: [
                ...this.requiredKeys
            ],
            pointerMode: [
                ...this.pointerMode
            ],
            preventIf: [
                ...this.preventIf
            ],
            pointerOptions: structuredClone(this.pointerOptions)
        }, overrides));
    }
    destroy() {
        this.resetState();
        super.destroy();
    }
    updateOptions(options) {
        super.updateOptions(options);
        this.direction = options.direction || this.direction;
        this.threshold = options.threshold ?? this.threshold;
    }
    resetState() {
        this.isActive = false;
        this.state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.state, {
            startPointers: new Map(),
            startCentroid: null,
            lastCentroid: null,
            lastDeltas: null,
            activeDeltaX: 0,
            activeDeltaY: 0,
            movementThresholdReached: false,
            lastDirection: {
                vertical: null,
                horizontal: null,
                mainAxis: null
            }
        });
    }
    /**
   * Handle pointer events for the pan gesture
   */ handlePointerEvent = (pointers, event)=>{
        const pointersArray = Array.from(pointers.values());
        // Check for our forceCancel event to handle interrupted gestures (from contextmenu, blur)
        if (event.type === 'forceCancel') {
            // Reset all active pan gestures when we get a force reset event
            this.cancel(event.target, pointersArray, event);
            return;
        }
        // Find which element (if any) is being targeted
        const targetElement = this.getTargetElement(event);
        if (!targetElement) {
            return;
        }
        // Check if this gesture should be prevented by active gestures
        if (this.shouldPreventGesture(targetElement, event.pointerType)) {
            // If the gesture was active but now should be prevented, cancel it gracefully
            this.cancel(targetElement, pointersArray, event);
            return;
        }
        // Filter pointers to only include those targeting our element or its children
        const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);
        if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {
            // Cancel or end the gesture if it was active
            this.cancel(targetElement, relevantPointers, event);
            return;
        }
        switch(event.type){
            case 'pointerdown':
                if (!this.isActive && !this.state.startCentroid) {
                    // Store initial pointers
                    relevantPointers.forEach((pointer)=>{
                        this.state.startPointers.set(pointer.pointerId, pointer);
                    });
                    // Store the original target element
                    this.originalTarget = targetElement;
                    // Calculate and store the starting centroid
                    this.state.startCentroid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateCentroid"])(relevantPointers);
                    this.state.lastCentroid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.state.startCentroid);
                }
                break;
            case 'pointermove':
                if (this.state.startCentroid && this.isWithinPointerCount(pointersArray, event.pointerType)) {
                    // Calculate current centroid
                    const currentCentroid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateCentroid"])(relevantPointers);
                    // Calculate delta from start
                    const distanceDeltaX = currentCentroid.x - this.state.startCentroid.x;
                    const distanceDeltaY = currentCentroid.y - this.state.startCentroid.y;
                    // Calculate movement distance
                    const distance = Math.sqrt(distanceDeltaX * distanceDeltaX + distanceDeltaY * distanceDeltaY);
                    // Determine movement direction
                    const moveDirection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$getDirection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getDirection"])(this.state.lastCentroid ?? this.state.startCentroid, currentCentroid);
                    // Calculate change in position since last move
                    const lastDeltaX = this.state.lastCentroid ? currentCentroid.x - this.state.lastCentroid.x : 0;
                    const lastDeltaY = this.state.lastCentroid ? currentCentroid.y - this.state.lastCentroid.y : 0;
                    // Check if movement passes the threshold and is in an allowed direction
                    if (!this.state.movementThresholdReached && distance >= this.threshold && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$isDirectionAllowed$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isDirectionAllowed"])(moveDirection, this.direction)) {
                        this.state.movementThresholdReached = true;
                        this.isActive = true;
                        // Update total accumulated delta
                        this.state.lastDeltas = {
                            x: lastDeltaX,
                            y: lastDeltaY
                        };
                        this.state.totalDeltaX += lastDeltaX;
                        this.state.totalDeltaY += lastDeltaY;
                        this.state.activeDeltaX += lastDeltaX;
                        this.state.activeDeltaY += lastDeltaY;
                        // Emit start event
                        this.emitPanEvent(targetElement, 'start', relevantPointers, event, currentCentroid);
                        this.emitPanEvent(targetElement, 'ongoing', relevantPointers, event, currentCentroid);
                    } else if (this.state.movementThresholdReached && this.isActive) {
                        // Update total accumulated delta
                        this.state.lastDeltas = {
                            x: lastDeltaX,
                            y: lastDeltaY
                        };
                        this.state.totalDeltaX += lastDeltaX;
                        this.state.totalDeltaY += lastDeltaY;
                        this.state.activeDeltaX += lastDeltaX;
                        this.state.activeDeltaY += lastDeltaY;
                        // Emit ongoing event
                        this.emitPanEvent(targetElement, 'ongoing', relevantPointers, event, currentCentroid);
                    }
                    // Update last centroid
                    this.state.lastCentroid = currentCentroid;
                    this.state.lastDirection = moveDirection;
                }
                break;
            case 'pointerup':
            case 'pointercancel':
            case 'forceCancel':
                // If the gesture was active (threshold was reached), emit end event
                if (this.isActive && this.state.movementThresholdReached) {
                    const remainingPointers = relevantPointers.filter((p)=>p.type !== 'pointerup' && p.type !== 'pointercancel');
                    // If we no longer meet the pointer count requirements, end the gesture
                    if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {
                        // End the gesture
                        const currentCentroid = this.state.lastCentroid || this.state.startCentroid;
                        if (event.type === 'pointercancel') {
                            this.emitPanEvent(targetElement, 'cancel', relevantPointers, event, currentCentroid);
                        }
                        this.emitPanEvent(targetElement, 'end', relevantPointers, event, currentCentroid);
                        this.resetState();
                    }
                } else {
                    this.resetState();
                }
                break;
            default:
                break;
        }
    };
    /**
   * Emit pan-specific events with additional data
   */ emitPanEvent(element, phase, pointers, event, currentCentroid) {
        if (!this.state.startCentroid) {
            return;
        }
        const deltaX = this.state.lastDeltas?.x ?? 0;
        const deltaY = this.state.lastDeltas?.y ?? 0;
        // Calculate velocity - time difference in seconds
        const firstPointer = this.state.startPointers.values().next().value;
        const timeElapsed = firstPointer ? (event.timeStamp - firstPointer.timeStamp) / 1000 : 0;
        const velocityX = timeElapsed > 0 ? deltaX / timeElapsed : 0;
        const velocityY = timeElapsed > 0 ? deltaY / timeElapsed : 0;
        const velocity = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
        // Get list of active gestures
        const activeGestures = this.gesturesRegistry.getActiveGestures(element);
        // Create custom event data
        const customEventData = {
            gestureName: this.name,
            initialCentroid: this.state.startCentroid,
            centroid: currentCentroid,
            target: event.target,
            srcEvent: event,
            phase,
            pointers,
            timeStamp: event.timeStamp,
            deltaX,
            deltaY,
            direction: this.state.lastDirection,
            velocityX,
            velocityY,
            velocity,
            totalDeltaX: this.state.totalDeltaX,
            totalDeltaY: this.state.totalDeltaY,
            activeDeltaX: this.state.activeDeltaX,
            activeDeltaY: this.state.activeDeltaY,
            activeGestures,
            customData: this.customData
        };
        // Event names to trigger
        const eventName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, phase);
        // Dispatch custom events on the element
        const domEvent = new CustomEvent(eventName, {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: customEventData
        });
        element.dispatchEvent(domEvent);
        // Apply preventDefault/stopPropagation if configured
        if (this.preventDefault) {
            event.preventDefault();
        }
        if (this.stopPropagation) {
            event.stopPropagation();
        }
    }
    /**
   * Cancel the current gesture
   */ cancel(element, pointers, event) {
        if (this.isActive) {
            const el = element ?? this.element;
            this.emitPanEvent(el, 'cancel', pointers, event, this.state.lastCentroid);
            this.emitPanEvent(el, 'end', pointers, event, this.state.lastCentroid);
        }
        this.resetState();
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/getDistance.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Calculate the distance between two points
 */ __turbopack_context__.s([
    "getDistance",
    ()=>getDistance
]);
function getDistance(pointA, pointB) {
    const deltaX = pointB.x - pointA.x;
    const deltaY = pointB.y - pointA.y;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/calculateAverageDistance.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "calculateAverageDistance",
    ()=>calculateAverageDistance
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$getDistance$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/getDistance.js [app-ssr] (ecmascript)");
;
function calculateAverageDistance(pointers) {
    if (pointers.length < 2) {
        return 0;
    }
    let totalDistance = 0;
    let pairCount = 0;
    // Calculate distance between each pair of pointers
    for(let i = 0; i < pointers.length; i += 1){
        for(let j = i + 1; j < pointers.length; j += 1){
            totalDistance += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$getDistance$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getDistance"])({
                x: pointers[i].clientX,
                y: pointers[i].clientY
            }, {
                x: pointers[j].clientX,
                y: pointers[j].clientY
            });
            pairCount += 1;
        }
    }
    // Return average distance
    return pairCount > 0 ? totalDistance / pairCount : 0;
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/getPinchDirection.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getPinchDirection",
    ()=>getPinchDirection
]);
const DIRECTION_THRESHOLD = 0;
const getPinchDirection = (velocity)=>{
    if (velocity > DIRECTION_THRESHOLD) {
        return 1; // Zooming in
    }
    if (velocity < -DIRECTION_THRESHOLD) {
        return -1; // Zooming out
    }
    return 0; // No significant movement
};
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/PinchGesture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PinchGesture",
    ()=>PinchGesture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-ssr] (ecmascript)");
/**
 * PinchGesture - Detects pinch (zoom) movements with two or more pointers
 *
 * This gesture tracks when multiple pointers move toward or away from each other, firing events when:
 * - Two or more pointers begin moving (start)
 * - The pointers continue changing distance (ongoing)
 * - One or more pointers are released or lifted (end)
 *
 * This gesture is commonly used to implement zoom functionality in touch interfaces.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/PointerGesture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateAverageDistance$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/calculateAverageDistance.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/calculateCentroid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/createEventName.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$getPinchDirection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/getPinchDirection.js [app-ssr] (ecmascript)");
;
;
;
class PinchGesture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PointerGesture"] {
    state = {
        startDistance: 0,
        lastDistance: 0,
        lastScale: 1,
        lastTime: 0,
        velocity: 0,
        totalScale: 1,
        deltaScale: 0
    };
    /**
   * Movement threshold in pixels that must be exceeded before the gesture activates.
   * Higher values reduce false positive gesture detection for small movements.
   */ constructor(options){
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, options, {
            minPointers: options.minPointers ?? 2
        }));
        this.threshold = options.threshold ?? 0;
    }
    clone(overrides) {
        return new PinchGesture((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            name: this.name,
            preventDefault: this.preventDefault,
            stopPropagation: this.stopPropagation,
            threshold: this.threshold,
            minPointers: this.minPointers,
            maxPointers: this.maxPointers,
            requiredKeys: [
                ...this.requiredKeys
            ],
            pointerMode: [
                ...this.pointerMode
            ],
            preventIf: [
                ...this.preventIf
            ],
            pointerOptions: structuredClone(this.pointerOptions)
        }, overrides));
    }
    destroy() {
        this.resetState();
        super.destroy();
    }
    updateOptions(options) {
        super.updateOptions(options);
    }
    resetState() {
        this.isActive = false;
        this.state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.state, {
            startDistance: 0,
            lastDistance: 0,
            lastScale: 1,
            lastTime: 0,
            velocity: 0,
            deltaScale: 0
        });
    }
    /**
   * Handle pointer events for the pinch gesture
   */ handlePointerEvent = (pointers, event)=>{
        const pointersArray = Array.from(pointers.values());
        // Find which element (if any) is being targeted
        const targetElement = this.getTargetElement(event);
        if (!targetElement) {
            return;
        }
        // Check if this gesture should be prevented by active gestures
        if (this.shouldPreventGesture(targetElement, event.pointerType)) {
            if (this.isActive) {
                // If the gesture was active but now should be prevented, end it gracefully
                this.emitPinchEvent(targetElement, 'cancel', pointersArray, event);
                this.resetState();
            }
            return;
        }
        // Filter pointers to only include those targeting our element or its children
        const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);
        switch(event.type){
            case 'pointerdown':
                if (relevantPointers.length >= 2 && !this.isActive) {
                    // Calculate and store the starting distance between pointers
                    const initialDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateAverageDistance$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateAverageDistance"])(relevantPointers);
                    this.state.startDistance = initialDistance;
                    this.state.lastDistance = initialDistance;
                    this.state.lastTime = event.timeStamp;
                    // Store the original target element
                    this.originalTarget = targetElement;
                }
                break;
            case 'pointermove':
                if (this.state.startDistance && this.isWithinPointerCount(relevantPointers, event.pointerType)) {
                    // Calculate current distance between pointers
                    const currentDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateAverageDistance$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateAverageDistance"])(relevantPointers);
                    // Calculate absolute distance change
                    const distanceChange = Math.abs(currentDistance - this.state.lastDistance);
                    // Only proceed if the distance between pointers has changed enough
                    if (distanceChange !== 0 && distanceChange >= this.threshold) {
                        // Calculate scale relative to starting distance
                        const scale = this.state.startDistance ? currentDistance / this.state.startDistance : 1;
                        // Calculate the relative scale change since last event
                        const scaleChange = scale / this.state.lastScale;
                        // Apply this change to the total accumulated scale
                        this.state.totalScale *= scaleChange;
                        // Calculate velocity (change in scale over time)
                        const deltaTime = (event.timeStamp - this.state.lastTime) / 1000; // convert to seconds
                        if (this.state.lastDistance) {
                            const deltaDistance = currentDistance - this.state.lastDistance;
                            const result = deltaDistance / deltaTime;
                            this.state.velocity = Number.isNaN(result) ? 0 : result;
                        }
                        // Update state
                        this.state.lastDistance = currentDistance;
                        this.state.deltaScale = scale - this.state.lastScale;
                        this.state.lastScale = scale;
                        this.state.lastTime = event.timeStamp;
                        if (!this.isActive) {
                            // Mark gesture as active
                            this.isActive = true;
                            // Emit start event
                            this.emitPinchEvent(targetElement, 'start', relevantPointers, event);
                            this.emitPinchEvent(targetElement, 'ongoing', relevantPointers, event);
                        } else {
                            // Emit ongoing event
                            this.emitPinchEvent(targetElement, 'ongoing', relevantPointers, event);
                        }
                    }
                }
                break;
            case 'pointerup':
            case 'pointercancel':
            case 'forceCancel':
                if (this.isActive) {
                    const remainingPointers = relevantPointers.filter((p)=>p.type !== 'pointerup' && p.type !== 'pointercancel');
                    // If we no longer meet the pointer count requirements, end the gesture
                    if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {
                        if (event.type === 'pointercancel') {
                            this.emitPinchEvent(targetElement, 'cancel', relevantPointers, event);
                        }
                        this.emitPinchEvent(targetElement, 'end', relevantPointers, event);
                        // Reset state
                        this.resetState();
                    } else if (remainingPointers.length >= 2) {
                        // If we still have enough pointers, update the start distance
                        // to prevent jumping when a finger is lifted
                        const newDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateAverageDistance$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateAverageDistance"])(remainingPointers);
                        this.state.startDistance = newDistance / this.state.lastScale;
                    }
                }
                break;
            default:
                break;
        }
    };
    /**
   * Emit pinch-specific events with additional data
   */ emitPinchEvent(element, phase, pointers, event) {
        // Calculate current centroid
        const centroid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateCentroid"])(pointers);
        // Create custom event data
        const distance = this.state.lastDistance;
        const scale = this.state.lastScale;
        // Get list of active gestures
        const activeGestures = this.gesturesRegistry.getActiveGestures(element);
        const customEventData = {
            gestureName: this.name,
            centroid,
            target: event.target,
            srcEvent: event,
            phase,
            pointers,
            timeStamp: event.timeStamp,
            scale,
            deltaScale: this.state.deltaScale,
            totalScale: this.state.totalScale,
            distance,
            velocity: this.state.velocity,
            activeGestures,
            direction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$getPinchDirection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPinchDirection"])(this.state.velocity),
            customData: this.customData
        };
        // Handle default event behavior
        if (this.preventDefault) {
            event.preventDefault();
        }
        if (this.stopPropagation) {
            event.stopPropagation();
        }
        // Event names to trigger
        const eventName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, phase);
        // Dispatch custom events on the element
        const domEvent = new CustomEvent(eventName, {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: customEventData
        });
        element.dispatchEvent(domEvent);
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/preventDefault.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "preventDefault",
    ()=>preventDefault
]);
const preventDefault = (event)=>{
    if (event.cancelable) {
        event.preventDefault();
    }
};
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/PressGesture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PressGesture",
    ()=>PressGesture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-ssr] (ecmascript)");
/**
 * PressGesture - Detects press and hold interactions
 *
 * This gesture tracks when users press and hold on an element for a specified duration, firing events when:
 * - The press begins and passes the holding threshold time (start, ongoing)
 * - The press ends (end)
 * - The press is canceled by movement beyond threshold (cancel)
 *
 * This gesture is commonly used for contextual menus, revealing additional options, or alternate actions.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/PointerGesture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/calculateCentroid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/createEventName.js [app-ssr] (ecmascript)");
;
;
;
class PressGesture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PointerGesture"] {
    state = {
        startCentroid: null,
        lastPosition: null,
        timerId: null,
        startTime: 0,
        pressThresholdReached: false
    };
    /**
   * Duration in milliseconds required to hold before the press gesture is recognized
   */ /**
   * Maximum distance a pointer can move for a gesture to still be considered a press
   */ constructor(options){
        super(options);
        this.duration = options.duration ?? 500;
        this.maxDistance = options.maxDistance ?? 10;
    }
    clone(overrides) {
        return new PressGesture((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            name: this.name,
            preventDefault: this.preventDefault,
            stopPropagation: this.stopPropagation,
            minPointers: this.minPointers,
            maxPointers: this.maxPointers,
            duration: this.duration,
            maxDistance: this.maxDistance,
            requiredKeys: [
                ...this.requiredKeys
            ],
            pointerMode: [
                ...this.pointerMode
            ],
            preventIf: [
                ...this.preventIf
            ],
            pointerOptions: structuredClone(this.pointerOptions)
        }, overrides));
    }
    destroy() {
        this.clearPressTimer();
        this.resetState();
        super.destroy();
    }
    updateOptions(options) {
        super.updateOptions(options);
        this.duration = options.duration ?? this.duration;
        this.maxDistance = options.maxDistance ?? this.maxDistance;
    }
    resetState() {
        this.clearPressTimer();
        this.isActive = false;
        this.state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.state, {
            startCentroid: null,
            lastPosition: null,
            timerId: null,
            startTime: 0,
            pressThresholdReached: false
        });
    }
    /**
   * Clear the press timer if it's active
   */ clearPressTimer() {
        if (this.state.timerId !== null) {
            clearTimeout(this.state.timerId);
            this.state.timerId = null;
        }
    }
    /**
   * Handle pointer events for the press gesture
   */ handlePointerEvent = (pointers, event)=>{
        const pointersArray = Array.from(pointers.values());
        // Check for our forceCancel event to handle interrupted gestures (from contextmenu, blur)
        if (event.type === 'forceCancel') {
            // Reset all active press gestures when we get a force reset event
            this.cancelPress(event.target, pointersArray, event);
            return;
        }
        // Find which element (if any) is being targeted
        const targetElement = this.getTargetElement(event);
        if (!targetElement) {
            return;
        }
        // Check if this gesture should be prevented by active gestures
        if (this.shouldPreventGesture(targetElement, event.pointerType)) {
            if (this.isActive) {
                // If the gesture was active but now should be prevented, cancel it gracefully
                this.cancelPress(targetElement, pointersArray, event);
            }
            return;
        }
        // Filter pointers to only include those targeting our element or its children
        const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);
        if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {
            if (this.isActive) {
                // Cancel or end the gesture if it was active
                this.cancelPress(targetElement, relevantPointers, event);
            }
            return;
        }
        switch(event.type){
            case 'pointerdown':
                if (!this.isActive && !this.state.startCentroid) {
                    // Calculate and store the starting centroid
                    this.state.startCentroid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateCentroid"])(relevantPointers);
                    this.state.lastPosition = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.state.startCentroid);
                    this.state.startTime = event.timeStamp;
                    this.isActive = true;
                    // Store the original target element
                    this.originalTarget = targetElement;
                    // Start the timer for press recognition
                    this.clearPressTimer(); // Clear any existing timer first
                    this.state.timerId = setTimeout(()=>{
                        if (this.isActive && this.state.startCentroid) {
                            this.state.pressThresholdReached = true;
                            const lastPosition = this.state.lastPosition;
                            // Emit press start event
                            this.emitPressEvent(targetElement, 'start', relevantPointers, event, lastPosition);
                            this.emitPressEvent(targetElement, 'ongoing', relevantPointers, event, lastPosition);
                        }
                    }, this.duration);
                }
                break;
            case 'pointermove':
                if (this.isActive && this.state.startCentroid) {
                    // Calculate current position
                    const currentPosition = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateCentroid"])(relevantPointers);
                    this.state.lastPosition = currentPosition;
                    // Calculate distance from start position
                    const deltaX = currentPosition.x - this.state.startCentroid.x;
                    const deltaY = currentPosition.y - this.state.startCentroid.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    // If moved too far, cancel the press gesture
                    if (distance > this.maxDistance) {
                        this.cancelPress(targetElement, relevantPointers, event);
                    }
                }
                break;
            case 'pointerup':
                if (this.isActive) {
                    if (this.state.pressThresholdReached) {
                        // Complete the press gesture if we've held long enough
                        const position = this.state.lastPosition || this.state.startCentroid;
                        this.emitPressEvent(targetElement, 'end', relevantPointers, event, position);
                    }
                    // Reset state
                    this.resetState();
                }
                break;
            case 'pointercancel':
            case 'forceCancel':
                // Cancel the gesture
                this.cancelPress(targetElement, relevantPointers, event);
                break;
            default:
                break;
        }
    };
    /**
   * Emit press-specific events with additional data
   */ emitPressEvent(element, phase, pointers, event, position) {
        // Get list of active gestures
        const activeGestures = this.gesturesRegistry.getActiveGestures(element);
        // Calculate current duration of the press
        const currentDuration = event.timeStamp - this.state.startTime;
        // Create custom event data
        const customEventData = {
            gestureName: this.name,
            centroid: position,
            target: event.target,
            srcEvent: event,
            phase,
            pointers,
            timeStamp: event.timeStamp,
            x: position.x,
            y: position.y,
            duration: currentDuration,
            activeGestures,
            customData: this.customData
        };
        // Event names to trigger
        const eventName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, phase);
        // Dispatch custom events on the element
        const domEvent = new CustomEvent(eventName, {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: customEventData
        });
        element.dispatchEvent(domEvent);
        // Apply preventDefault/stopPropagation if configured
        if (this.preventDefault) {
            event.preventDefault();
        }
        if (this.stopPropagation) {
            event.stopPropagation();
        }
    }
    /**
   * Cancel the current press gesture
   */ cancelPress(element, pointers, event) {
        if (this.isActive && this.state.pressThresholdReached) {
            const position = this.state.lastPosition || this.state.startCentroid;
            this.emitPressEvent(element ?? this.element, 'cancel', pointers, event, position);
            this.emitPressEvent(element ?? this.element, 'end', pointers, event, position);
        }
        this.resetState();
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/PressAndDragGesture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PressAndDragGesture",
    ()=>PressAndDragGesture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-ssr] (ecmascript)");
/**
 * PressAndDragGesture - Detects press followed by drag gestures using composition
 *
 * This gesture uses internal PressGesture and PanGesture instances to:
 * 1. First, detect a press (hold for specified duration without movement)
 * 2. Then, track drag movements from the press position
 *
 * The gesture fires events when:
 * - A press is completed (press phase)
 * - Drag movement begins and passes threshold (dragStart)
 * - Drag movement continues (drag)
 * - Drag movement ends (dragEnd)
 * - The gesture is canceled at any point
 *
 * This is ideal for panning operations where you want to hold first, then drag.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/PointerGesture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/createEventName.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$preventDefault$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/preventDefault.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$gestures$2f$PanGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/PanGesture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$gestures$2f$PressGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/PressGesture.js [app-ssr] (ecmascript)");
;
;
;
;
;
class PressAndDragGesture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PointerGesture"] {
    state = {
        phase: 'waitingForPress',
        dragTimeoutId: null
    };
    /**
   * Duration required for press recognition
   */ /**
   * Maximum distance a pointer can move during press for it to still be considered a press
   */ /**
   * Maximum time between press completion and drag start
   */ /**
   * Movement threshold for drag activation
   */ /**
   * Allowed directions for the drag gesture
   */ constructor(options){
        super(options);
        this.pressDuration = options.pressDuration ?? 500;
        this.pressMaxDistance = options.pressMaxDistance ?? 10;
        this.dragTimeout = options.dragTimeout ?? 1000;
        this.dragThreshold = options.dragThreshold ?? 0;
        this.dragDirection = options.dragDirection || [
            'up',
            'down',
            'left',
            'right'
        ];
        this.pressGesture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$gestures$2f$PressGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PressGesture"]({
            name: `${this.name}-press`,
            duration: this.pressDuration,
            maxDistance: this.pressMaxDistance,
            maxPointers: this.maxPointers,
            pointerMode: this.pointerMode,
            requiredKeys: this.requiredKeys,
            preventIf: this.preventIf,
            pointerOptions: structuredClone(this.pointerOptions)
        });
        this.panGesture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$gestures$2f$PanGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PanGesture"]({
            name: `${this.name}-pan`,
            minPointers: this.minPointers,
            maxPointers: this.maxPointers,
            threshold: this.dragThreshold,
            direction: this.dragDirection,
            pointerMode: this.pointerMode,
            requiredKeys: this.requiredKeys,
            preventIf: this.preventIf,
            pointerOptions: structuredClone(this.pointerOptions)
        });
    }
    clone(overrides) {
        return new PressAndDragGesture((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            name: this.name,
            preventDefault: this.preventDefault,
            stopPropagation: this.stopPropagation,
            minPointers: this.minPointers,
            maxPointers: this.maxPointers,
            pressDuration: this.pressDuration,
            pressMaxDistance: this.pressMaxDistance,
            dragTimeout: this.dragTimeout,
            dragThreshold: this.dragThreshold,
            dragDirection: [
                ...this.dragDirection
            ],
            requiredKeys: [
                ...this.requiredKeys
            ],
            pointerMode: [
                ...this.pointerMode
            ],
            preventIf: [
                ...this.preventIf
            ],
            pointerOptions: structuredClone(this.pointerOptions)
        }, overrides));
    }
    init(element, pointerManager, gestureRegistry, keyboardManager) {
        super.init(element, pointerManager, gestureRegistry, keyboardManager);
        this.pressGesture.init(element, pointerManager, gestureRegistry, keyboardManager);
        this.panGesture.init(element, pointerManager, gestureRegistry, keyboardManager);
        // Listen to press gesture events
        this.element.addEventListener(this.pressGesture.name, this.pressHandler);
        // Listen to pan gesture events for dragging
        // @ts-expect-error, PointerEvent is correct.
        this.element.addEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.addEventListener(this.panGesture.name, this.dragMoveHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.addEventListener(`${this.panGesture.name}End`, this.dragEndHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.addEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);
    }
    destroy() {
        this.resetState();
        this.pressGesture.destroy();
        this.panGesture.destroy();
        this.element.removeEventListener(this.pressGesture.name, this.pressHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.removeEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.removeEventListener(this.panGesture.name, this.dragMoveHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.removeEventListener(`${this.panGesture.name}End`, this.dragEndHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.removeEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);
        super.destroy();
    }
    updateOptions(options) {
        super.updateOptions(options);
        this.pressDuration = options.pressDuration ?? this.pressDuration;
        this.pressMaxDistance = options.pressMaxDistance ?? this.pressMaxDistance;
        this.dragTimeout = options.dragTimeout ?? this.dragTimeout;
        this.dragThreshold = options.dragThreshold ?? this.dragThreshold;
        this.dragDirection = options.dragDirection || this.dragDirection;
        // Update internal gesture options
        this.element.dispatchEvent(new CustomEvent(`${this.panGesture.name}ChangeOptions`, {
            detail: {
                minPointers: this.minPointers,
                maxPointers: this.maxPointers,
                threshold: this.dragThreshold,
                direction: this.dragDirection,
                pointerMode: this.pointerMode,
                requiredKeys: this.requiredKeys,
                preventIf: this.preventIf,
                pointerOptions: structuredClone(this.pointerOptions)
            }
        }));
        this.element.dispatchEvent(new CustomEvent(`${this.pressGesture.name}ChangeOptions`, {
            detail: {
                duration: this.pressDuration,
                maxDistance: this.pressMaxDistance,
                maxPointers: this.maxPointers,
                pointerMode: this.pointerMode,
                requiredKeys: this.requiredKeys,
                preventIf: this.preventIf,
                pointerOptions: structuredClone(this.pointerOptions)
            }
        }));
    }
    resetState() {
        if (this.state.dragTimeoutId !== null) {
            clearTimeout(this.state.dragTimeoutId);
        }
        this.restoreTouchAction();
        this.isActive = false;
        this.state = {
            phase: 'waitingForPress',
            dragTimeoutId: null
        };
    }
    /**
   * This can be empty because the PressAndDragGesture relies on PressGesture and PanGesture to handle pointer events
   * The internal gestures will manage their own state and events, while this class coordinates between them
   */ handlePointerEvent() {}
    pressHandler = ()=>{
        if (this.state.phase !== 'waitingForPress') {
            return;
        }
        this.state.phase = 'pressDetected';
        this.setTouchAction();
        // Start timeout to wait for drag start
        this.state.dragTimeoutId = setTimeout(()=>{
            // Timeout expired, reset gesture
            this.resetState();
        }, this.dragTimeout);
    };
    dragStartHandler = (event)=>{
        if (this.state.phase !== 'pressDetected') {
            return;
        }
        // Clear the drag timeout as drag has started
        if (this.state.dragTimeoutId !== null) {
            clearTimeout(this.state.dragTimeoutId);
            this.state.dragTimeoutId = null;
        }
        // Restore touch action since we're now dragging
        this.restoreTouchAction();
        this.state.phase = 'dragging';
        this.isActive = true;
        // Fire start event
        this.element.dispatchEvent(new CustomEvent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, event.detail.phase), event));
    };
    dragMoveHandler = (event)=>{
        if (this.state.phase !== 'dragging') {
            return;
        }
        // Fire move event
        this.element.dispatchEvent(new CustomEvent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, event.detail.phase), event));
    };
    dragEndHandler = (event)=>{
        if (this.state.phase !== 'dragging') {
            return;
        }
        this.resetState();
        // Fire end event
        this.element.dispatchEvent(new CustomEvent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, event.detail.phase), event));
    };
    setTouchAction() {
        this.element.addEventListener('touchstart', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$preventDefault$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["preventDefault"], {
            passive: false
        });
        this.element.addEventListener('touchmove', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$preventDefault$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["preventDefault"], {
            passive: false
        });
        this.element.addEventListener('touchend', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$preventDefault$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["preventDefault"], {
            passive: false
        });
    }
    restoreTouchAction() {
        this.element.removeEventListener('touchstart', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$preventDefault$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["preventDefault"]);
        this.element.removeEventListener('touchmove', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$preventDefault$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["preventDefault"]);
        this.element.removeEventListener('touchend', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$preventDefault$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["preventDefault"]);
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/TapGesture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TapGesture",
    ()=>TapGesture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-ssr] (ecmascript)");
/**
 * TapGesture - Detects tap (quick touch without movement) gestures
 *
 * This gesture tracks simple tap interactions on elements, firing a single event when:
 * - A complete tap is detected (pointerup after brief touch without excessive movement)
 * - The tap is canceled (event.g., moved too far or held too long)
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/PointerGesture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/calculateCentroid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/createEventName.js [app-ssr] (ecmascript)");
;
;
;
class TapGesture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PointerGesture"] {
    state = {
        startCentroid: null,
        currentTapCount: 0,
        lastTapTime: 0,
        lastPosition: null
    };
    /**
   * Maximum distance a pointer can move for a gesture to still be considered a tap
   */ /**
   * Number of consecutive taps to detect
   */ constructor(options){
        super(options);
        this.maxDistance = options.maxDistance ?? 10;
        this.taps = options.taps ?? 1;
    }
    clone(overrides) {
        return new TapGesture((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            name: this.name,
            preventDefault: this.preventDefault,
            stopPropagation: this.stopPropagation,
            minPointers: this.minPointers,
            maxPointers: this.maxPointers,
            maxDistance: this.maxDistance,
            taps: this.taps,
            requiredKeys: [
                ...this.requiredKeys
            ],
            pointerMode: [
                ...this.pointerMode
            ],
            preventIf: [
                ...this.preventIf
            ],
            pointerOptions: structuredClone(this.pointerOptions)
        }, overrides));
    }
    destroy() {
        this.resetState();
        super.destroy();
    }
    updateOptions(options) {
        super.updateOptions(options);
        this.maxDistance = options.maxDistance ?? this.maxDistance;
        this.taps = options.taps ?? this.taps;
    }
    resetState() {
        this.isActive = false;
        this.state = {
            startCentroid: null,
            currentTapCount: 0,
            lastTapTime: 0,
            lastPosition: null
        };
    }
    /**
   * Handle pointer events for the tap gesture
   */ handlePointerEvent = (pointers, event)=>{
        const pointersArray = Array.from(pointers.values());
        // Find which element (if any) is being targeted
        const targetElement = this.getTargetElement(event);
        if (!targetElement) {
            return;
        }
        // Filter pointers to only include those targeting our element or its children
        const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);
        if (this.shouldPreventGesture(targetElement, event.pointerType) || !this.isWithinPointerCount(relevantPointers, event.pointerType)) {
            if (this.isActive) {
                // Cancel the gesture if it was active
                this.cancelTap(targetElement, relevantPointers, event);
            }
            return;
        }
        switch(event.type){
            case 'pointerdown':
                if (!this.isActive) {
                    // Calculate and store the starting centroid
                    this.state.startCentroid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateCentroid"])(relevantPointers);
                    this.state.lastPosition = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.state.startCentroid);
                    this.isActive = true;
                    // Store the original target element
                    this.originalTarget = targetElement;
                }
                break;
            case 'pointermove':
                if (this.isActive && this.state.startCentroid) {
                    // Calculate current position
                    const currentPosition = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateCentroid"])(relevantPointers);
                    this.state.lastPosition = currentPosition;
                    // Calculate distance from start position
                    const deltaX = currentPosition.x - this.state.startCentroid.x;
                    const deltaY = currentPosition.y - this.state.startCentroid.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    // If moved too far, cancel the tap gesture
                    if (distance > this.maxDistance) {
                        this.cancelTap(targetElement, relevantPointers, event);
                    }
                }
                break;
            case 'pointerup':
                if (this.isActive) {
                    // For valid tap: increment tap count
                    this.state.currentTapCount += 1;
                    // Make sure we have a valid position before firing the tap event
                    const position = this.state.lastPosition || this.state.startCentroid;
                    if (!position) {
                        this.cancelTap(targetElement, relevantPointers, event);
                        return;
                    }
                    // Check if we've reached the desired number of taps
                    if (this.state.currentTapCount >= this.taps) {
                        // The complete tap sequence has been detected - fire the tap event
                        this.fireTapEvent(targetElement, relevantPointers, event, position);
                        // Reset state after successful tap
                        this.resetState();
                    } else {
                        // Store the time of this tap for multi-tap detection
                        this.state.lastTapTime = event.timeStamp;
                        // Reset active state but keep the tap count for multi-tap detection
                        this.isActive = false;
                        // For multi-tap detection: keep track of the last tap position
                        // but clear the start centroid to prepare for next tap
                        this.state.startCentroid = null;
                        // Start a timeout to reset the tap count if the next tap doesn't come soon enough
                        setTimeout(()=>{
                            if (this.state && this.state.currentTapCount > 0 && this.state.currentTapCount < this.taps) {
                                this.state.currentTapCount = 0;
                            }
                        }, 300); // 300ms is a typical double-tap detection window
                    }
                }
                break;
            case 'pointercancel':
            case 'forceCancel':
                // Cancel the gesture
                this.cancelTap(targetElement, relevantPointers, event);
                break;
            default:
                break;
        }
    };
    /**
   * Fire the main tap event when a valid tap is detected
   */ fireTapEvent(element, pointers, event, position) {
        // Get list of active gestures
        const activeGestures = this.gesturesRegistry.getActiveGestures(element);
        // Create custom event data for the tap event
        const customEventData = {
            gestureName: this.name,
            centroid: position,
            target: event.target,
            srcEvent: event,
            phase: 'end',
            // The tap is complete, so we use 'end' state for the event data
            pointers,
            timeStamp: event.timeStamp,
            x: position.x,
            y: position.y,
            tapCount: this.state.currentTapCount,
            activeGestures,
            customData: this.customData
        };
        // Dispatch a single 'tap' event (not 'tapStart', 'tapEnd', etc.)
        const domEvent = new CustomEvent(this.name, {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: customEventData
        });
        element.dispatchEvent(domEvent);
        // Apply preventDefault/stopPropagation if configured
        if (this.preventDefault) {
            event.preventDefault();
        }
        if (this.stopPropagation) {
            event.stopPropagation();
        }
    }
    /**
   * Cancel the current tap gesture
   */ cancelTap(element, pointers, event) {
        if (this.state.startCentroid || this.state.lastPosition) {
            const position = this.state.lastPosition || this.state.startCentroid;
            // Get list of active gestures
            const activeGestures = this.gesturesRegistry.getActiveGestures(element);
            // Create custom event data for the cancel event
            const customEventData = {
                gestureName: this.name,
                centroid: position,
                target: event.target,
                srcEvent: event,
                phase: 'cancel',
                pointers,
                timeStamp: event.timeStamp,
                x: position.x,
                y: position.y,
                tapCount: this.state.currentTapCount,
                activeGestures,
                customData: this.customData
            };
            // Dispatch a 'tapCancel' event
            const eventName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, 'cancel');
            const domEvent = new CustomEvent(eventName, {
                bubbles: true,
                cancelable: true,
                composed: true,
                detail: customEventData
            });
            element.dispatchEvent(domEvent);
        }
        this.resetState();
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/TapAndDragGesture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TapAndDragGesture",
    ()=>TapAndDragGesture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-ssr] (ecmascript)");
/**
 * TapAndDragGesture - Detects tap followed by drag gestures using composition
 *
 * This gesture uses internal TapGesture and PanGesture instances to:
 * 1. First, detect a tap (quick touch without movement)
 * 2. Then, track drag movements on the next pointer down
 *
 * The gesture fires events when:
 * - A tap is completed (tap phase)
 * - Drag movement begins and passes threshold (dragStart)
 * - Drag movement continues (drag)
 * - Drag movement ends (dragEnd)
 * - The gesture is canceled at any point
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/PointerGesture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/createEventName.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$preventDefault$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/preventDefault.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$gestures$2f$PanGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/PanGesture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$gestures$2f$TapGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/TapGesture.js [app-ssr] (ecmascript)");
;
;
;
;
;
class TapAndDragGesture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$PointerGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PointerGesture"] {
    state = {
        phase: 'waitingForTap',
        dragTimeoutId: null
    };
    /**
   * Maximum distance a pointer can move during tap for it to still be considered a tap
   * (Following TapGesture pattern)
   */ /**
   * Maximum time between tap completion and drag start
   */ /**
   * Movement threshold for drag activation
   */ /**
   * Allowed directions for the drag gesture
   */ constructor(options){
        super(options);
        this.tapMaxDistance = options.tapMaxDistance ?? 10;
        this.dragTimeout = options.dragTimeout ?? 1000;
        this.dragThreshold = options.dragThreshold ?? 0;
        this.dragDirection = options.dragDirection || [
            'up',
            'down',
            'left',
            'right'
        ];
        this.tapGesture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$gestures$2f$TapGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TapGesture"]({
            name: `${this.name}-tap`,
            maxDistance: this.tapMaxDistance,
            maxPointers: this.maxPointers,
            pointerMode: this.pointerMode,
            requiredKeys: this.requiredKeys,
            preventIf: this.preventIf,
            pointerOptions: structuredClone(this.pointerOptions)
        });
        this.panGesture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$gestures$2f$PanGesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PanGesture"]({
            name: `${this.name}-pan`,
            minPointers: this.minPointers,
            maxPointers: this.maxPointers,
            threshold: this.dragThreshold,
            direction: this.dragDirection,
            pointerMode: this.pointerMode,
            requiredKeys: this.requiredKeys,
            preventIf: this.preventIf,
            pointerOptions: structuredClone(this.pointerOptions)
        });
    }
    clone(overrides) {
        return new TapAndDragGesture((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            name: this.name,
            preventDefault: this.preventDefault,
            stopPropagation: this.stopPropagation,
            minPointers: this.minPointers,
            maxPointers: this.maxPointers,
            tapMaxDistance: this.tapMaxDistance,
            dragTimeout: this.dragTimeout,
            dragThreshold: this.dragThreshold,
            dragDirection: [
                ...this.dragDirection
            ],
            requiredKeys: [
                ...this.requiredKeys
            ],
            pointerMode: [
                ...this.pointerMode
            ],
            preventIf: [
                ...this.preventIf
            ],
            pointerOptions: structuredClone(this.pointerOptions)
        }, overrides));
    }
    init(element, pointerManager, gestureRegistry, keyboardManager) {
        super.init(element, pointerManager, gestureRegistry, keyboardManager);
        this.tapGesture.init(element, pointerManager, gestureRegistry, keyboardManager);
        this.panGesture.init(element, pointerManager, gestureRegistry, keyboardManager);
        this.element.addEventListener(this.tapGesture.name, this.tapHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.addEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.addEventListener(this.panGesture.name, this.dragMoveHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.addEventListener(`${this.panGesture.name}End`, this.dragEndHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.addEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);
    }
    destroy() {
        this.resetState();
        this.tapGesture.destroy();
        this.panGesture.destroy();
        this.element.removeEventListener(this.tapGesture.name, this.tapHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.removeEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.removeEventListener(this.panGesture.name, this.dragMoveHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.removeEventListener(`${this.panGesture.name}End`, this.dragEndHandler);
        // @ts-expect-error, PointerEvent is correct.
        this.element.removeEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);
        super.destroy();
    }
    updateOptions(options) {
        super.updateOptions(options);
        this.tapMaxDistance = options.tapMaxDistance ?? this.tapMaxDistance;
        this.dragTimeout = options.dragTimeout ?? this.dragTimeout;
        this.dragThreshold = options.dragThreshold ?? this.dragThreshold;
        this.dragDirection = options.dragDirection || this.dragDirection;
        this.element.dispatchEvent(new CustomEvent(`${this.panGesture.name}ChangeOptions`, {
            detail: {
                minPointers: this.minPointers,
                maxPointers: this.maxPointers,
                threshold: this.dragThreshold,
                direction: this.dragDirection,
                pointerMode: this.pointerMode,
                requiredKeys: this.requiredKeys,
                preventIf: this.preventIf,
                pointerOptions: structuredClone(this.pointerOptions)
            }
        }));
        this.element.dispatchEvent(new CustomEvent(`${this.tapGesture.name}ChangeOptions`, {
            detail: {
                maxDistance: this.tapMaxDistance,
                maxPointers: this.maxPointers,
                pointerMode: this.pointerMode,
                requiredKeys: this.requiredKeys,
                preventIf: this.preventIf,
                pointerOptions: structuredClone(this.pointerOptions)
            }
        }));
    }
    resetState() {
        if (this.state.dragTimeoutId !== null) {
            clearTimeout(this.state.dragTimeoutId);
        }
        this.restoreTouchAction();
        this.isActive = false;
        this.state = {
            phase: 'waitingForTap',
            dragTimeoutId: null
        };
    }
    /**
   * This can be empty because the TapAndDragGesture relies on TapGesture and PanGesture to handle pointer events
   * The internal gestures will manage their own state and events, while this class coordinates between them
   */ handlePointerEvent() {}
    tapHandler = ()=>{
        if (this.state.phase !== 'waitingForTap') {
            return;
        }
        this.state.phase = 'tapDetected';
        this.setTouchAction();
        // Start timeout to wait for drag start
        this.state.dragTimeoutId = setTimeout(()=>{
            // Timeout expired, reset gesture
            this.resetState();
        }, this.dragTimeout);
    };
    dragStartHandler = (event)=>{
        if (this.state.phase !== 'tapDetected') {
            return;
        }
        // Clear the drag timeout as drag has started
        if (this.state.dragTimeoutId !== null) {
            clearTimeout(this.state.dragTimeoutId);
            this.state.dragTimeoutId = null;
        }
        this.restoreTouchAction();
        this.state.phase = 'dragging';
        this.isActive = true;
        // Fire start event
        this.element.dispatchEvent(new CustomEvent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, event.detail.phase), event));
    };
    dragMoveHandler = (event)=>{
        if (this.state.phase !== 'dragging') {
            return;
        }
        // Fire move event
        this.element.dispatchEvent(new CustomEvent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, event.detail.phase), event));
    };
    dragEndHandler = (event)=>{
        if (this.state.phase !== 'dragging') {
            return;
        }
        this.resetState();
        // Fire end event
        this.element.dispatchEvent(new CustomEvent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, event.detail.phase), event));
    };
    setTouchAction() {
        this.element.addEventListener('touchstart', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$preventDefault$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["preventDefault"], {
            passive: false
        });
    }
    restoreTouchAction() {
        this.element.removeEventListener('touchstart', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$preventDefault$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["preventDefault"]);
    }
}
}),
"[project]/node_modules/@mui/x-internal-gestures/esm/core/gestures/TurnWheelGesture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TurnWheelGesture",
    ()=>TurnWheelGesture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-ssr] (ecmascript)");
/**
 * TurnWheelGesture - Detects wheel events on an element
 *
 * This gesture tracks mouse wheel or touchpad scroll events on elements, firing events when:
 * - The user scrolls/wheels on the element (ongoing)
 *
 * Unlike other gestures which may have start/ongoing/end states,
 * wheel gestures are always considered "ongoing" since they are discrete events.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$Gesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/Gesture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/calculateCentroid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mui/x-internal-gestures/esm/core/utils/createEventName.js [app-ssr] (ecmascript)");
;
;
;
class TurnWheelGesture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$Gesture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Gesture"] {
    state = {
        totalDeltaX: 0,
        totalDeltaY: 0,
        totalDeltaZ: 0
    };
    /**
   * Scaling factor for delta values
   * Values > 1 increase sensitivity, values < 1 decrease sensitivity
   */ /**
   * Maximum value for totalDelta values
   * Limits how large the accumulated wheel deltas can be
   */ /**
   * Minimum value for totalDelta values
   * Sets a lower bound for accumulated wheel deltas
   */ /**
   * Initial value for totalDelta values
   * Sets the starting value for delta trackers
   */ /**
   * Whether to invert the direction of delta changes
   * When true, reverses the sign of deltaX, deltaY, and deltaZ values
   */ constructor(options){
        super(options);
        this.sensitivity = options.sensitivity ?? 1;
        this.max = options.max ?? Number.MAX_SAFE_INTEGER;
        this.min = options.min ?? Number.MIN_SAFE_INTEGER;
        this.initialDelta = options.initialDelta ?? 0;
        this.invert = options.invert ?? false;
        this.state.totalDeltaX = this.initialDelta;
        this.state.totalDeltaY = this.initialDelta;
        this.state.totalDeltaZ = this.initialDelta;
    }
    clone(overrides) {
        return new TurnWheelGesture((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            name: this.name,
            preventDefault: this.preventDefault,
            stopPropagation: this.stopPropagation,
            sensitivity: this.sensitivity,
            max: this.max,
            min: this.min,
            initialDelta: this.initialDelta,
            invert: this.invert,
            requiredKeys: [
                ...this.requiredKeys
            ],
            preventIf: [
                ...this.preventIf
            ]
        }, overrides));
    }
    init(element, pointerManager, gestureRegistry, keyboardManager) {
        super.init(element, pointerManager, gestureRegistry, keyboardManager);
        // Add event listener directly to the element
        // @ts-expect-error, WheelEvent is correct.
        this.element.addEventListener('wheel', this.handleWheelEvent);
    }
    destroy() {
        // Remove the element-specific event listener
        // @ts-expect-error, WheelEvent is correct.
        this.element.removeEventListener('wheel', this.handleWheelEvent);
        this.resetState();
        super.destroy();
    }
    resetState() {
        this.isActive = false;
        this.state = {
            totalDeltaX: 0,
            totalDeltaY: 0,
            totalDeltaZ: 0
        };
    }
    updateOptions(options) {
        super.updateOptions(options);
        this.sensitivity = options.sensitivity ?? this.sensitivity;
        this.max = options.max ?? this.max;
        this.min = options.min ?? this.min;
        this.initialDelta = options.initialDelta ?? this.initialDelta;
        this.invert = options.invert ?? this.invert;
    }
    /**
   * Handle wheel events for a specific element
   * @param element The element that received the wheel event
   * @param event The original wheel event
   */ handleWheelEvent = (event)=>{
        // Check if this gesture should be prevented by active gestures
        if (this.shouldPreventGesture(this.element, 'mouse')) {
            return;
        }
        // Get pointers from the PointerManager to use for centroid calculation
        const pointers = this.pointerManager.getPointers() || new Map();
        const pointersArray = Array.from(pointers.values());
        // Update total deltas with scaled values
        this.state.totalDeltaX += event.deltaX * this.sensitivity * (this.invert ? -1 : 1);
        this.state.totalDeltaY += event.deltaY * this.sensitivity * (this.invert ? -1 : 1);
        this.state.totalDeltaZ += event.deltaZ * this.sensitivity * (this.invert ? -1 : 1);
        // Apply proper min/max clamping for each axis
        // Ensure values stay between min and max bounds
        [
            'totalDeltaX',
            'totalDeltaY',
            'totalDeltaZ'
        ].forEach((axis)=>{
            // First clamp at the minimum bound
            if (this.state[axis] < this.min) {
                this.state[axis] = this.min;
            }
            // Then clamp at the maximum bound
            if (this.state[axis] > this.max) {
                this.state[axis] = this.max;
            }
        });
        // Emit the wheel event
        this.emitWheelEvent(pointersArray, event);
    };
    /**
   * Emit wheel-specific events
   * @param pointers The current pointers on the element
   * @param event The original wheel event
   */ emitWheelEvent(pointers, event) {
        // Calculate centroid - either from existing pointers or from the wheel event position
        const centroid = pointers.length > 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$calculateCentroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateCentroid"])(pointers) : {
            x: event.clientX,
            y: event.clientY
        };
        // Get list of active gestures
        const activeGestures = this.gesturesRegistry.getActiveGestures(this.element);
        // Create custom event data
        const customEventData = {
            gestureName: this.name,
            centroid,
            target: event.target,
            srcEvent: event,
            phase: 'ongoing',
            // Wheel events are always in "ongoing" state
            pointers,
            timeStamp: event.timeStamp,
            deltaX: event.deltaX * this.sensitivity * (this.invert ? -1 : 1),
            deltaY: event.deltaY * this.sensitivity * (this.invert ? -1 : 1),
            deltaZ: event.deltaZ * this.sensitivity * (this.invert ? -1 : 1),
            deltaMode: event.deltaMode,
            totalDeltaX: this.state.totalDeltaX,
            totalDeltaY: this.state.totalDeltaY,
            totalDeltaZ: this.state.totalDeltaZ,
            activeGestures,
            customData: this.customData
        };
        // Apply default event behavior if configured
        if (this.preventDefault) {
            event.preventDefault();
        }
        if (this.stopPropagation) {
            event.stopPropagation();
        }
        // Event names to trigger
        const eventName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mui$2f$x$2d$internal$2d$gestures$2f$esm$2f$core$2f$utils$2f$createEventName$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEventName"])(this.name, 'ongoing');
        // Dispatch custom events on the element
        const domEvent = new CustomEvent(eventName, {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: customEventData
        });
        this.element.dispatchEvent(domEvent);
    }
}
}),
];

//# sourceMappingURL=node_modules_%40mui_x-internal-gestures_esm_core_7a7ca655._.js.map