{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/ActiveGesturesRegistry.js"],"sourcesContent":["/**\n * ActiveGesturesRegistry - Centralized registry for tracking which gestures are active on elements\n *\n * This singleton class keeps track of all gesture instances that are currently in their active state,\n * allowing both the system and applications to query which gestures are active on specific elements.\n */\n\n/**\n * Type for entries in the active gestures registry\n */\n\n/**\n * Registry that maintains a record of all currently active gestures across elements\n */\nexport class ActiveGesturesRegistry {\n  /** Map of elements to their active gestures */\n  activeGestures = (() => new Map())();\n\n  /**\n   * Register a gesture as active on an element\n   *\n   * @param element - The DOM element on which the gesture is active\n   * @param gesture - The gesture instance that is active\n   */\n  registerActiveGesture(element, gesture) {\n    if (!this.activeGestures.has(element)) {\n      this.activeGestures.set(element, new Set());\n    }\n    const elementGestures = this.activeGestures.get(element);\n    const entry = {\n      gesture,\n      element\n    };\n    elementGestures.add(entry);\n  }\n\n  /**\n   * Remove a gesture from the active registry\n   *\n   * @param element - The DOM element on which the gesture was active\n   * @param gesture - The gesture instance to deactivate\n   */\n  unregisterActiveGesture(element, gesture) {\n    const elementGestures = this.activeGestures.get(element);\n    if (!elementGestures) {\n      return;\n    }\n\n    // Find and remove the specific gesture entry\n    elementGestures.forEach(entry => {\n      if (entry.gesture === gesture) {\n        elementGestures.delete(entry);\n      }\n    });\n\n    // Remove the element from the map if it no longer has any active gestures\n    if (elementGestures.size === 0) {\n      this.activeGestures.delete(element);\n    }\n  }\n\n  /**\n   * Get all active gestures for a specific element\n   *\n   * @param element - The DOM element to query\n   * @returns Array of active gesture names\n   */\n  getActiveGestures(element) {\n    const elementGestures = this.activeGestures.get(element);\n    if (!elementGestures) {\n      return {};\n    }\n    return Array.from(elementGestures).reduce((acc, entry) => {\n      acc[entry.gesture.name] = true;\n      return acc;\n    }, {});\n  }\n\n  /**\n   * Check if a specific gesture is active on an element\n   *\n   * @param element - The DOM element to check\n   * @param gesture - The gesture instance to check\n   * @returns True if the gesture is active on the element, false otherwise\n   */\n  isGestureActive(element, gesture) {\n    const elementGestures = this.activeGestures.get(element);\n    if (!elementGestures) {\n      return false;\n    }\n    return Array.from(elementGestures).some(entry => entry.gesture === gesture);\n  }\n\n  /**\n   * Clear all active gestures from the registry\n   */\n  destroy() {\n    this.activeGestures.clear();\n  }\n\n  /**\n   * Clear all active gestures for a specific element\n   *\n   * @param element - The DOM element to clear\n   */\n  unregisterElement(element) {\n    this.activeGestures.delete(element);\n  }\n}"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED;;CAEC,GAED;;CAEC;;;;AACM,MAAM;IACX,6CAA6C,GAC7C,iBAAiB,CAAC,IAAM,IAAI,KAAK,IAAI;IAErC;;;;;GAKC,GACD,sBAAsB,OAAO,EAAE,OAAO,EAAE;QACtC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU;YACrC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,SAAS,IAAI;QACvC;QACA,MAAM,kBAAkB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC;QAChD,MAAM,QAAQ;YACZ;YACA;QACF;QACA,gBAAgB,GAAG,CAAC;IACtB;IAEA;;;;;GAKC,GACD,wBAAwB,OAAO,EAAE,OAAO,EAAE;QACxC,MAAM,kBAAkB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC;QAChD,IAAI,CAAC,iBAAiB;YACpB;QACF;QAEA,6CAA6C;QAC7C,gBAAgB,OAAO,CAAC,CAAA;YACtB,IAAI,MAAM,OAAO,KAAK,SAAS;gBAC7B,gBAAgB,MAAM,CAAC;YACzB;QACF;QAEA,0EAA0E;QAC1E,IAAI,gBAAgB,IAAI,KAAK,GAAG;YAC9B,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC;QAC7B;IACF;IAEA;;;;;GAKC,GACD,kBAAkB,OAAO,EAAE;QACzB,MAAM,kBAAkB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC;QAChD,IAAI,CAAC,iBAAiB;YACpB,OAAO,CAAC;QACV;QACA,OAAO,MAAM,IAAI,CAAC,iBAAiB,MAAM,CAAC,CAAC,KAAK;YAC9C,GAAG,CAAC,MAAM,OAAO,CAAC,IAAI,CAAC,GAAG;YAC1B,OAAO;QACT,GAAG,CAAC;IACN;IAEA;;;;;;GAMC,GACD,gBAAgB,OAAO,EAAE,OAAO,EAAE;QAChC,MAAM,kBAAkB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC;QAChD,IAAI,CAAC,iBAAiB;YACpB,OAAO;QACT;QACA,OAAO,MAAM,IAAI,CAAC,iBAAiB,IAAI,CAAC,CAAA,QAAS,MAAM,OAAO,KAAK;IACrE;IAEA;;GAEC,GACD,UAAU;QACR,IAAI,CAAC,cAAc,CAAC,KAAK;IAC3B;IAEA;;;;GAIC,GACD,kBAAkB,OAAO,EAAE;QACzB,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC;IAC7B;AACF","ignoreList":[0]}},
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/KeyboardManager.js"],"sourcesContent":["/**\n * KeyboardManager - Manager for keyboard events in the gesture recognition system\n *\n * This class tracks keyboard state:\n * 1. Capturing and tracking all pressed keys\n * 2. Providing methods to check if specific keys are pressed\n */\n\n/**\n * Type definition for keyboard keys\n */\n\n/**\n * Class responsible for tracking keyboard state\n */\nexport class KeyboardManager {\n  pressedKeys = (() => new Set())();\n\n  /**\n   * Create a new KeyboardManager instance\n   */\n  constructor() {\n    this.initialize();\n  }\n\n  /**\n   * Initialize the keyboard event listeners\n   */\n  initialize() {\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    // Add keyboard event listeners\n    window.addEventListener('keydown', this.handleKeyDown);\n    window.addEventListener('keyup', this.handleKeyUp);\n    // Reset keys when window loses focus\n    window.addEventListener('blur', this.clearKeys);\n  }\n\n  /**\n   * Handle keydown events\n   */\n  handleKeyDown = event => {\n    this.pressedKeys.add(event.key);\n  };\n\n  /**\n   * Handle keyup events\n   */\n  handleKeyUp = event => {\n    this.pressedKeys.delete(event.key);\n  };\n\n  /**\n   * Clear all pressed keys\n   */\n  clearKeys = () => {\n    this.pressedKeys.clear();\n  };\n\n  /**\n   * Check if a set of keys are all currently pressed\n   * @param keys The keys to check\n   * @returns True if all specified keys are pressed, false otherwise\n   */\n  areKeysPressed(keys) {\n    if (!keys || keys.length === 0) {\n      return true; // No keys required means the condition is satisfied\n    }\n    return keys.every(key => {\n      if (key === 'ControlOrMeta') {\n        // May be \"deprecated\" on types, but it is still the best option for cross-platform detection\n        // https://stackoverflow.com/a/71785253/24269134\n        return navigator.platform.includes('Mac') ? this.pressedKeys.has('Meta') : this.pressedKeys.has('Control');\n      }\n      return this.pressedKeys.has(key);\n    });\n  }\n\n  /**\n   * Cleanup method to remove event listeners\n   */\n  destroy() {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('keydown', this.handleKeyDown);\n      window.removeEventListener('keyup', this.handleKeyUp);\n      window.removeEventListener('blur', this.clearKeys);\n    }\n    this.clearKeys();\n  }\n}"],"names":[],"mappings":"AAAA;;;;;;CAMC,GAED;;CAEC,GAED;;CAEC;;;;AACM,MAAM;IACX,cAAc,CAAC,IAAM,IAAI,KAAK,IAAI;IAElC;;GAEC,GACD,aAAc;QACZ,IAAI,CAAC,UAAU;IACjB;IAEA;;GAEC,GACD,aAAa;QACX,wCAAmC;YACjC;QACF;;;IAOF;IAEA;;GAEC,GACD,gBAAgB,CAAA;QACd,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,GAAG;IAChC,EAAE;IAEF;;GAEC,GACD,cAAc,CAAA;QACZ,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,GAAG;IACnC,EAAE;IAEF;;GAEC,GACD,YAAY;QACV,IAAI,CAAC,WAAW,CAAC,KAAK;IACxB,EAAE;IAEF;;;;GAIC,GACD,eAAe,IAAI,EAAE;QACnB,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GAAG;YAC9B,OAAO,MAAM,oDAAoD;QACnE;QACA,OAAO,KAAK,KAAK,CAAC,CAAA;YAChB,IAAI,QAAQ,iBAAiB;gBAC3B,6FAA6F;gBAC7F,gDAAgD;gBAChD,OAAO,UAAU,QAAQ,CAAC,QAAQ,CAAC,SAAS,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,UAAU,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC;YAClG;YACA,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC;QAC9B;IACF;IAEA;;GAEC,GACD,UAAU;QACR;;QAKA,IAAI,CAAC,SAAS;IAChB;AACF","ignoreList":[0]}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/PointerManager.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PointerManager - Centralized manager for pointer events in the gesture recognition system\n *\n * This singleton class abstracts the complexity of working with pointer events by:\n * 1. Capturing and tracking all active pointers (touch, mouse, pen)\n * 2. Normalizing pointer data into a consistent format\n * 3. Managing pointer capture for proper tracking across elements\n * 4. Distributing events to registered gesture recognizers\n */\n\n/**\n * Normalized representation of a pointer, containing all relevant information\n * from the original PointerEvent plus additional tracking data.\n *\n * This data structure encapsulates everything gesture recognizers need to know\n * about a pointer's current state.\n */\n\n/**\n * Configuration options for initializing the PointerManager.\n */\n\n/**\n * Manager for handling pointer events across the application.\n *\n * PointerManager serves as the foundational layer for gesture recognition,\n * providing a centralized system for tracking active pointers and distributing\n * pointer events to gesture recognizers.\n *\n * It normalizes browser pointer events into a consistent format and simplifies\n * multi-touch handling by managing pointer capture and tracking multiple\n * simultaneous pointers.\n */\nexport class PointerManager {\n  /** Root element where pointer events are captured */\n\n  /** CSS touch-action property value applied to the root element */\n\n  /** Whether to use passive event listeners */\n\n  /** Whether to prevent interrupt events like blur or contextmenu */\n  preventEventInterruption = true;\n\n  /** Map of all currently active pointers by their pointerId */\n  pointers = (() => new Map())();\n\n  /** Set of registered gesture handlers that receive pointer events */\n  gestureHandlers = (() => new Set())();\n  constructor(options) {\n    this.root =\n    // User provided root element\n    options.root ??\n    // Fallback to document root or body, this fixes shadow DOM scenarios\n    document.getRootNode({\n      composed: true\n    }) ??\n    // Fallback to document body, for some testing environments\n    document.body;\n    this.touchAction = options.touchAction || 'auto';\n    this.passive = options.passive ?? false;\n    this.preventEventInterruption = options.preventEventInterruption ?? true;\n    this.setupEventListeners();\n  }\n\n  /**\n   * Register a handler function to receive pointer events.\n   *\n   * The handler will be called whenever pointer events occur within the root element.\n   * It receives the current map of all active pointers and the original event.\n   *\n   * @param {Function} handler - Function to receive pointer events and current pointer state\n   * @returns {Function} An unregister function that removes this handler when called\n   */\n  registerGestureHandler(handler) {\n    this.gestureHandlers.add(handler);\n\n    // Return unregister function\n    return () => {\n      this.gestureHandlers.delete(handler);\n    };\n  }\n\n  /**\n   * Get a copy of the current active pointers map.\n   *\n   * Returns a new Map containing all currently active pointers.\n   * Modifying the returned map will not affect the internal pointers state.\n   *\n   * @returns A new Map containing all active pointers\n   */\n  getPointers() {\n    return new Map(this.pointers);\n  }\n\n  /**\n   * Set up event listeners for pointer events on the root element.\n   *\n   * This method attaches all necessary event listeners and configures\n   * the CSS touch-action property on the root element.\n   */\n  setupEventListeners() {\n    // Set touch-action CSS property\n    if (this.touchAction !== 'auto') {\n      this.root.style.touchAction = this.touchAction;\n    }\n\n    // Add event listeners\n    this.root.addEventListener('pointerdown', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    this.root.addEventListener('pointermove', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    this.root.addEventListener('pointerup', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    this.root.addEventListener('pointercancel', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    // @ts-expect-error, forceCancel is not a standard event, but used for custom handling\n    this.root.addEventListener('forceCancel', this.handlePointerEvent, {\n      passive: this.passive\n    });\n\n    // Add blur and contextmenu event listeners to interrupt all gestures\n    this.root.addEventListener('blur', this.handleInterruptEvents);\n    this.root.addEventListener('contextmenu', this.handleInterruptEvents);\n  }\n\n  /**\n   * Handle events that should interrupt all gestures.\n   * This clears all active pointers and notifies handlers with a pointercancel-like event.\n   *\n   * @param event - The event that triggered the interruption (blur or contextmenu)\n   */\n  handleInterruptEvents = event => {\n    if (this.preventEventInterruption && 'pointerType' in event && event.pointerType === 'touch') {\n      event.preventDefault();\n      return;\n    }\n\n    // Create a synthetic pointer cancel event\n    const cancelEvent = new PointerEvent('forceCancel', {\n      bubbles: false,\n      cancelable: false\n    });\n    const firstPointer = this.pointers.values().next().value;\n    if (this.pointers.size > 0 && firstPointer) {\n      // If there are active pointers, use the first one as a template for coordinates\n\n      // Update the synthetic event with the pointer's coordinates\n      Object.defineProperties(cancelEvent, {\n        clientX: {\n          value: firstPointer.clientX\n        },\n        clientY: {\n          value: firstPointer.clientY\n        },\n        pointerId: {\n          value: firstPointer.pointerId\n        },\n        pointerType: {\n          value: firstPointer.pointerType\n        }\n      });\n\n      // Force update of all pointers to have type 'forceCancel'\n      for (const [pointerId, pointer] of this.pointers.entries()) {\n        const updatedPointer = _extends({}, pointer, {\n          type: 'forceCancel'\n        });\n        this.pointers.set(pointerId, updatedPointer);\n      }\n    }\n\n    // Notify all handlers about the interruption\n    this.notifyHandlers(cancelEvent);\n\n    // Clear all pointers\n    this.pointers.clear();\n  };\n\n  /**\n   * Event handler for all pointer events.\n   *\n   * This method:\n   * 1. Updates the internal pointers map based on the event type\n   * 2. Manages pointer capture for tracking pointers outside the root element\n   * 3. Notifies all registered handlers with the current state\n   *\n   * @param event - The original pointer event from the browser\n   */\n  handlePointerEvent = event => {\n    const {\n      type,\n      pointerId\n    } = event;\n\n    // Create or update pointer data\n    if (type === 'pointerdown' || type === 'pointermove') {\n      this.pointers.set(pointerId, this.createPointerData(event));\n    }\n    // Remove pointer data on up or cancel\n    else if (type === 'pointerup' || type === 'pointercancel' || type === 'forceCancel') {\n      // Update one last time before removing\n      this.pointers.set(pointerId, this.createPointerData(event));\n\n      // Notify handlers with current state\n      this.notifyHandlers(event);\n\n      // Then remove the pointer\n      this.pointers.delete(pointerId);\n      return;\n    }\n    this.notifyHandlers(event);\n  };\n\n  /**\n   * Notify all registered gesture handlers about a pointer event.\n   *\n   * Each handler receives the current map of active pointers and the original event.\n   *\n   * @param event - The original pointer event that triggered this notification\n   */\n  notifyHandlers(event) {\n    this.gestureHandlers.forEach(handler => handler(this.pointers, event));\n  }\n\n  /**\n   * Create a normalized PointerData object from a browser PointerEvent.\n   *\n   * This method extracts all relevant information from the original event\n   * and formats it in a consistent way for gesture recognizers to use.\n   *\n   * @param event - The original browser pointer event\n   * @returns A new PointerData object representing this pointer\n   */\n  createPointerData(event) {\n    return {\n      pointerId: event.pointerId,\n      clientX: event.clientX,\n      clientY: event.clientY,\n      pageX: event.pageX,\n      pageY: event.pageY,\n      target: event.target,\n      timeStamp: event.timeStamp,\n      type: event.type,\n      isPrimary: event.isPrimary,\n      pressure: event.pressure,\n      width: event.width,\n      height: event.height,\n      pointerType: event.pointerType,\n      srcEvent: event\n    };\n  }\n\n  /**\n   * Clean up all event listeners and reset the PointerManager state.\n   *\n   * This method should be called when the PointerManager is no longer needed\n   * to prevent memory leaks. It removes all event listeners, clears the\n   * internal state, and resets the singleton instance.\n   */\n  destroy() {\n    this.root.removeEventListener('pointerdown', this.handlePointerEvent);\n    this.root.removeEventListener('pointermove', this.handlePointerEvent);\n    this.root.removeEventListener('pointerup', this.handlePointerEvent);\n    this.root.removeEventListener('pointercancel', this.handlePointerEvent);\n    // @ts-expect-error, forceCancel is not a standard event, but used for custom handling\n    this.root.removeEventListener('forceCancel', this.handlePointerEvent);\n    this.root.removeEventListener('blur', this.handleInterruptEvents);\n    this.root.removeEventListener('contextmenu', this.handleInterruptEvents);\n    this.pointers.clear();\n    this.gestureHandlers.clear();\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/GestureManager.js"],"sourcesContent":["import { ActiveGesturesRegistry } from \"./ActiveGesturesRegistry.js\";\nimport { KeyboardManager } from \"./KeyboardManager.js\";\nimport { PointerManager } from \"./PointerManager.js\";\n\n/**\n * Configuration options for initializing the GestureManager\n */\n\n/**\n * The primary class responsible for setting up and managing gestures across multiple elements.\n *\n * GestureManager maintains a collection of gesture templates that can be instantiated for\n * specific DOM elements. It handles lifecycle management, event dispatching, and cleanup.\n *\n * @example\n * ```typescript\n * // Basic setup with default gestures\n * const manager = new GestureManager({\n *   root: document.body,\n *   touchAction: 'none',\n *   gestures: [\n *     new PanGesture({ name: 'pan' }),\n *   ],\n * });\n *\n * // Register pan gestures on an element\n * const element = manager.registerElement('pan', document.querySelector('.draggable'));\n *\n * // Add event listeners with proper typing\n * element.addEventListener('panStart', (event) => {\n *   console.log('Pan started');\n * });\n *\n * element.addEventListener('pan', (event) => {\n *   console.log(`Pan delta: ${event.deltaX}, ${event.deltaY}`);\n * });\n *\n * // Custom gesture types\n * interface MyGestureEvents {\n *   custom: { x: number, y: number }\n * }\n * const customManager = new GestureManager<MyGestureEvents>({\n *   root: document.body\n *   gestures: [\n *     new CustomGesture({ name: 'custom' }),\n *   ],\n * });\n * ```\n */\nexport class GestureManager {\n  /** Repository of gesture templates that can be cloned for specific elements */\n  gestureTemplates = (() => new Map())();\n\n  /** Maps DOM elements to their active gesture instances */\n  elementGestureMap = (() => new Map())();\n  activeGesturesRegistry = (() => new ActiveGesturesRegistry())();\n  keyboardManager = (() => new KeyboardManager())();\n\n  /**\n   * Create a new GestureManager instance to coordinate gesture recognition\n   *\n   * @param options - Configuration options for the gesture manager\n   */\n  constructor(options) {\n    // Initialize the PointerManager\n    this.pointerManager = new PointerManager({\n      root: options.root,\n      touchAction: options.touchAction,\n      passive: options.passive\n    });\n\n    // Add initial gestures as templates if provided\n    if (options.gestures && options.gestures.length > 0) {\n      options.gestures.forEach(gesture => {\n        this.addGestureTemplate(gesture);\n      });\n    }\n  }\n\n  /**\n   * Add a gesture template to the manager's template registry.\n   * Templates serve as prototypes that can be cloned for individual elements.\n   *\n   * @param gesture - The gesture instance to use as a template\n   */\n  addGestureTemplate(gesture) {\n    if (this.gestureTemplates.has(gesture.name)) {\n      console.warn(`Gesture template with name \"${gesture.name}\" already exists. It will be overwritten.`);\n    }\n    this.gestureTemplates.set(gesture.name, gesture);\n  }\n\n  /**\n   * Updates the options for a specific gesture on a given element and emits a change event.\n   *\n   * @param gestureName - Name of the gesture whose options should be updated\n   * @param element - The DOM element where the gesture is attached\n   * @param options - New options to apply to the gesture\n   * @returns True if the options were successfully updated, false if the gesture wasn't found\n   *\n   * @example\n   * ```typescript\n   * // Update pan gesture sensitivity on the fly\n   * manager.setGestureOptions('pan', element, { threshold: 5 });\n   * ```\n   */\n  setGestureOptions(gestureName, element, options) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (!elementGestures || !elementGestures.has(gestureName)) {\n      console.error(`Gesture \"${gestureName}\" not found on the provided element.`);\n      return;\n    }\n    const event = new CustomEvent(`${gestureName}ChangeOptions`, {\n      detail: options,\n      bubbles: false,\n      cancelable: false,\n      composed: false\n    });\n    element.dispatchEvent(event);\n  }\n\n  /**\n   * Updates the state for a specific gesture on a given element and emits a change event.\n   *\n   * @param gestureName - Name of the gesture whose state should be updated\n   * @param element - The DOM element where the gesture is attached\n   * @param state - New state to apply to the gesture\n   * @returns True if the state was successfully updated, false if the gesture wasn't found\n   *\n   * @example\n   * ```typescript\n   * // Update total delta for a turnWheel gesture\n   * manager.setGestureState('turnWheel', element, { totalDeltaX: 10 });\n   * ```\n   */\n  setGestureState(gestureName, element, state) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (!elementGestures || !elementGestures.has(gestureName)) {\n      console.error(`Gesture \"${gestureName}\" not found on the provided element.`);\n      return;\n    }\n    const event = new CustomEvent(`${gestureName}ChangeState`, {\n      detail: state,\n      bubbles: false,\n      cancelable: false,\n      composed: false\n    });\n    element.dispatchEvent(event);\n  }\n\n  /**\n   * Register an element to recognize one or more gestures.\n   *\n   * This method clones the specified gesture template(s) and creates\n   * gesture recognizer instance(s) specifically for the provided element.\n   * The element is returned with enhanced TypeScript typing for gesture events.\n   *\n   * @param gestureNames - Name(s) of the gesture(s) to register (must match template names)\n   * @param element - The DOM element to attach the gesture(s) to\n   * @param options - Optional map of gesture-specific options to override when registering\n   * @returns The same element with properly typed event listeners\n   *\n   * @example\n   * ```typescript\n   * // Register multiple gestures\n   * const element = manager.registerElement(['pan', 'pinch'], myDiv);\n   *\n   * // Register a single gesture\n   * const draggable = manager.registerElement('pan', dragHandle);\n   *\n   * // Register with customized options for each gesture\n   * const customElement = manager.registerElement(\n   *   ['pan', 'pinch', 'rotate'],\n   *   myElement,\n   *   {\n   *     pan: { threshold: 20, direction: ['left', 'right'] },\n   *     pinch: { threshold: 0.1 }\n   *   }\n   * );\n   * ```\n   */\n  registerElement(gestureNames, element, options) {\n    // Handle array of gesture names\n    if (!Array.isArray(gestureNames)) {\n      gestureNames = [gestureNames];\n    }\n    gestureNames.forEach(name => {\n      const gestureOptions = options?.[name];\n      this.registerSingleGesture(name, element, gestureOptions);\n    });\n    return element;\n  }\n\n  /**\n   * Internal method to register a single gesture on an element.\n   *\n   * @param gestureName - Name of the gesture to register\n   * @param element - DOM element to attach the gesture to\n   * @param options - Optional options to override the gesture template configuration\n   * @returns True if the registration was successful, false otherwise\n   */\n  registerSingleGesture(gestureName, element, options) {\n    // Find the gesture template\n    const gestureTemplate = this.gestureTemplates.get(gestureName);\n    if (!gestureTemplate) {\n      console.error(`Gesture template \"${gestureName}\" not found.`);\n      return false;\n    }\n\n    // Create element's gesture map if it doesn't exist\n    if (!this.elementGestureMap.has(element)) {\n      this.elementGestureMap.set(element, new Map());\n    }\n\n    // Check if this element already has this gesture registered\n    const elementGestures = this.elementGestureMap.get(element);\n    if (elementGestures.has(gestureName)) {\n      console.warn(`Element already has gesture \"${gestureName}\" registered. It will be replaced.`);\n      // Unregister the existing gesture first\n      this.unregisterElement(gestureName, element);\n    }\n\n    // Clone the gesture template and create a new instance with optional overrides\n    // This allows each element to have its own state, event listeners, and configuration\n    const gestureInstance = gestureTemplate.clone(options);\n    gestureInstance.init(element, this.pointerManager, this.activeGesturesRegistry, this.keyboardManager);\n\n    // Store the gesture in the element's gesture map\n    elementGestures.set(gestureName, gestureInstance);\n    return true;\n  }\n\n  /**\n   * Unregister a specific gesture from an element.\n   * This removes the gesture recognizer and stops event emission for that gesture.\n   *\n   * @param gestureName - Name of the gesture to unregister\n   * @param element - The DOM element to remove the gesture from\n   * @returns True if the gesture was found and removed, false otherwise\n   */\n  unregisterElement(gestureName, element) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (!elementGestures || !elementGestures.has(gestureName)) {\n      return false;\n    }\n\n    // Destroy the gesture instance\n    const gesture = elementGestures.get(gestureName);\n    gesture.destroy();\n\n    // Remove from the map\n    elementGestures.delete(gestureName);\n    this.activeGesturesRegistry.unregisterElement(element);\n\n    // Remove the element from the map if it no longer has any gestures\n    if (elementGestures.size === 0) {\n      this.elementGestureMap.delete(element);\n    }\n    return true;\n  }\n\n  /**\n   * Unregister all gestures from an element.\n   * Completely removes the element from the gesture system.\n   *\n   * @param element - The DOM element to remove all gestures from\n   */\n  unregisterAllGestures(element) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (elementGestures) {\n      // Unregister all gestures for this element\n      for (const [, gesture] of elementGestures) {\n        gesture.destroy();\n        this.activeGesturesRegistry.unregisterElement(element);\n      }\n\n      // Clear the map\n      this.elementGestureMap.delete(element);\n    }\n  }\n\n  /**\n   * Clean up all gestures and event listeners.\n   * Call this method when the GestureManager is no longer needed to prevent memory leaks.\n   */\n  destroy() {\n    // Unregister all element gestures\n    for (const [element] of this.elementGestureMap) {\n      this.unregisterAllGestures(element);\n    }\n\n    // Clear all templates\n    this.gestureTemplates.clear();\n    this.elementGestureMap.clear();\n    this.activeGesturesRegistry.destroy();\n    this.keyboardManager.destroy();\n    this.pointerManager.destroy();\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 617, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/utils/eventList.js"],"sourcesContent":["export const eventList = {\n  abort: true,\n  animationcancel: true,\n  animationend: true,\n  animationiteration: true,\n  animationstart: true,\n  auxclick: true,\n  beforeinput: true,\n  beforetoggle: true,\n  blur: true,\n  cancel: true,\n  canplay: true,\n  canplaythrough: true,\n  change: true,\n  click: true,\n  close: true,\n  compositionend: true,\n  compositionstart: true,\n  compositionupdate: true,\n  contextlost: true,\n  contextmenu: true,\n  contextrestored: true,\n  copy: true,\n  cuechange: true,\n  cut: true,\n  dblclick: true,\n  drag: true,\n  dragend: true,\n  dragenter: true,\n  dragleave: true,\n  dragover: true,\n  dragstart: true,\n  drop: true,\n  durationchange: true,\n  emptied: true,\n  ended: true,\n  error: true,\n  focus: true,\n  focusin: true,\n  focusout: true,\n  formdata: true,\n  gotpointercapture: true,\n  input: true,\n  invalid: true,\n  keydown: true,\n  keypress: true,\n  keyup: true,\n  load: true,\n  loadeddata: true,\n  loadedmetadata: true,\n  loadstart: true,\n  lostpointercapture: true,\n  mousedown: true,\n  mouseenter: true,\n  mouseleave: true,\n  mousemove: true,\n  mouseout: true,\n  mouseover: true,\n  mouseup: true,\n  paste: true,\n  pause: true,\n  play: true,\n  playing: true,\n  pointercancel: true,\n  pointerdown: true,\n  pointerenter: true,\n  pointerleave: true,\n  pointermove: true,\n  pointerout: true,\n  pointerover: true,\n  pointerup: true,\n  progress: true,\n  ratechange: true,\n  reset: true,\n  resize: true,\n  scroll: true,\n  scrollend: true,\n  securitypolicyviolation: true,\n  seeked: true,\n  seeking: true,\n  select: true,\n  selectionchange: true,\n  selectstart: true,\n  slotchange: true,\n  stalled: true,\n  submit: true,\n  suspend: true,\n  timeupdate: true,\n  toggle: true,\n  touchcancel: true,\n  touchend: true,\n  touchmove: true,\n  touchstart: true,\n  transitioncancel: true,\n  transitionend: true,\n  transitionrun: true,\n  transitionstart: true,\n  volumechange: true,\n  waiting: true,\n  webkitanimationend: true,\n  webkitanimationiteration: true,\n  webkitanimationstart: true,\n  webkittransitionend: true,\n  wheel: true,\n  beforematch: true,\n  pointerrawupdate: true\n};"],"names":[],"mappings":";;;;AAAO,MAAM,YAAY;IACvB,OAAO;IACP,iBAAiB;IACjB,cAAc;IACd,oBAAoB;IACpB,gBAAgB;IAChB,UAAU;IACV,aAAa;IACb,cAAc;IACd,MAAM;IACN,QAAQ;IACR,SAAS;IACT,gBAAgB;IAChB,QAAQ;IACR,OAAO;IACP,OAAO;IACP,gBAAgB;IAChB,kBAAkB;IAClB,mBAAmB;IACnB,aAAa;IACb,aAAa;IACb,iBAAiB;IACjB,MAAM;IACN,WAAW;IACX,KAAK;IACL,UAAU;IACV,MAAM;IACN,SAAS;IACT,WAAW;IACX,WAAW;IACX,UAAU;IACV,WAAW;IACX,MAAM;IACN,gBAAgB;IAChB,SAAS;IACT,OAAO;IACP,OAAO;IACP,OAAO;IACP,SAAS;IACT,UAAU;IACV,UAAU;IACV,mBAAmB;IACnB,OAAO;IACP,SAAS;IACT,SAAS;IACT,UAAU;IACV,OAAO;IACP,MAAM;IACN,YAAY;IACZ,gBAAgB;IAChB,WAAW;IACX,oBAAoB;IACpB,WAAW;IACX,YAAY;IACZ,YAAY;IACZ,WAAW;IACX,UAAU;IACV,WAAW;IACX,SAAS;IACT,OAAO;IACP,OAAO;IACP,MAAM;IACN,SAAS;IACT,eAAe;IACf,aAAa;IACb,cAAc;IACd,cAAc;IACd,aAAa;IACb,YAAY;IACZ,aAAa;IACb,WAAW;IACX,UAAU;IACV,YAAY;IACZ,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,WAAW;IACX,yBAAyB;IACzB,QAAQ;IACR,SAAS;IACT,QAAQ;IACR,iBAAiB;IACjB,aAAa;IACb,YAAY;IACZ,SAAS;IACT,QAAQ;IACR,SAAS;IACT,YAAY;IACZ,QAAQ;IACR,aAAa;IACb,UAAU;IACV,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,eAAe;IACf,eAAe;IACf,iBAAiB;IACjB,cAAc;IACd,SAAS;IACT,oBAAoB;IACpB,0BAA0B;IAC1B,sBAAsB;IACtB,qBAAqB;IACrB,OAAO;IACP,aAAa;IACb,kBAAkB;AACpB","ignoreList":[0]}},
    {"offset": {"line": 732, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/Gesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * Base Gesture module that provides common functionality for all gesture implementations\n */\n\nimport { eventList } from \"./utils/eventList.js\";\n\n/**\n * The possible phases of a gesture during its lifecycle.\n *\n * - 'start': The gesture has been recognized and is beginning\n * - 'ongoing': The gesture is in progress (e.g., a finger is moving)\n * - 'end': The gesture has completed successfully\n * - 'cancel': The gesture was interrupted or terminated abnormally\n */\n\n/**\n * Core data structure passed to gesture event handlers.\n * Contains all relevant information about a gesture event.\n */\n\n/**\n * Defines the types of pointers that can trigger a gesture.\n */\n\n/**\n * Base configuration options that can be overridden per pointer mode.\n */\n\n/**\n * Configuration options for creating a gesture instance.\n */\n\n// eslint-disable-next-line no-underscore-dangle, @typescript-eslint/naming-convention\n\n/**\n * Type for the state of a gesture recognizer.\n */\n\n/**\n * Base abstract class for all gestures. This class provides the fundamental structure\n * and functionality for handling gestures, including registering and unregistering\n * gesture handlers, creating emitters, and managing gesture state.\n *\n * Gesture is designed as an extensible base for implementing specific gesture recognizers.\n * Concrete gesture implementations should extend this class or one of its subclasses.\n *\n * To implement:\n * - Non-pointer gestures (like wheel events): extend this Gesture class directly\n * - Pointer-based gestures: extend the PointerGesture class instead\n *\n * @example\n * ```ts\n * import { Gesture } from './Gesture';\n *\n * class CustomGesture extends Gesture {\n *   constructor(options) {\n *     super(options);\n *   }\n *\n *   clone(overrides) {\n *     return new CustomGesture({\n *       name: this.name,\n *       // ... other options\n *       ...overrides,\n *     });\n *   }\n * }\n * ```\n */\nexport class Gesture {\n  /** Unique name identifying this gesture type */\n\n  /** Whether to prevent default browser action for gesture events */\n\n  /** Whether to stop propagation of gesture events */\n\n  /**\n   * List of gesture names that should prevent this gesture from activating when they are active.\n   */\n\n  /**\n   * Array of keyboard keys that must be pressed for the gesture to be recognized.\n   */\n\n  /**\n   * KeyboardManager instance for tracking key presses\n   */\n\n  /**\n   * List of pointer types that can trigger this gesture.\n   * If undefined, all pointer types are allowed.\n   */\n\n  /**\n   * Pointer mode-specific configuration overrides.\n   */\n\n  /**\n   * User-mutable data object for sharing state between gesture events\n   * This object is included in all events emitted by this gesture\n   */\n  customData = {};\n\n  /** Reference to the singleton PointerManager instance */\n\n  /** Reference to the singleton ActiveGesturesRegistry instance */\n\n  /** The DOM element this gesture is attached to */\n\n  /** Stores the active gesture state */\n\n  /** @internal For types. If false enables phases (xStart, x, xEnd) */\n\n  /** @internal For types. The event type this gesture is associated with */\n\n  /** @internal For types. The options type for this gesture */\n\n  /** @internal For types. The options that can be changed at runtime */\n\n  /** @internal For types. The state that can be changed at runtime */\n\n  /**\n   * Create a new gesture instance with the specified options\n   *\n   * @param options - Configuration options for this gesture\n   */\n  constructor(options) {\n    if (!options || !options.name) {\n      throw new Error('Gesture must be initialized with a valid name.');\n    }\n    if (options.name in eventList) {\n      throw new Error(`Gesture can't be created with a native event name. Tried to use \"${options.name}\". Please use a custom name instead.`);\n    }\n    this.name = options.name;\n    this.preventDefault = options.preventDefault ?? false;\n    this.stopPropagation = options.stopPropagation ?? false;\n    this.preventIf = options.preventIf ?? [];\n    this.requiredKeys = options.requiredKeys ?? [];\n    this.pointerMode = options.pointerMode ?? [];\n    this.pointerOptions = options.pointerOptions ?? {};\n  }\n\n  /**\n   * Initialize the gesture by acquiring the pointer manager and gestures registry\n   * Must be called before the gesture can be used\n   */\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    this.element = element;\n    this.pointerManager = pointerManager;\n    this.gesturesRegistry = gestureRegistry;\n    this.keyboardManager = keyboardManager;\n    const changeOptionsEventName = `${this.name}ChangeOptions`;\n    this.element.addEventListener(changeOptionsEventName, this.handleOptionsChange);\n    const changeStateEventName = `${this.name}ChangeState`;\n    this.element.addEventListener(changeStateEventName, this.handleStateChange);\n  }\n\n  /**\n   * Handle option change events\n   * @param event Custom event with new options in the detail property\n   */\n  handleOptionsChange = event => {\n    if (event && event.detail) {\n      this.updateOptions(event.detail);\n    }\n  };\n\n  /**\n   * Update the gesture options with new values\n   * @param options Object containing properties to update\n   */\n  updateOptions(options) {\n    // Update common options\n    this.preventDefault = options.preventDefault ?? this.preventDefault;\n    this.stopPropagation = options.stopPropagation ?? this.stopPropagation;\n    this.preventIf = options.preventIf ?? this.preventIf;\n    this.requiredKeys = options.requiredKeys ?? this.requiredKeys;\n    this.pointerMode = options.pointerMode ?? this.pointerMode;\n    this.pointerOptions = options.pointerOptions ?? this.pointerOptions;\n  }\n\n  /**\n   * Get the default configuration for the pointer specific options.\n   * Change this function in child classes to provide different defaults.\n   */\n  getBaseConfig() {\n    return {\n      requiredKeys: this.requiredKeys\n    };\n  }\n\n  /**\n   * Get the effective configuration for a specific pointer mode.\n   * This merges the base configuration with pointer mode-specific overrides.\n   *\n   * @param pointerType - The pointer type to get configuration for\n   * @returns The effective configuration object\n   */\n  getEffectiveConfig(pointerType, baseConfig) {\n    if (pointerType !== 'mouse' && pointerType !== 'touch' && pointerType !== 'pen') {\n      // Unknown pointer type, return base config\n      return baseConfig;\n    }\n\n    // Apply pointer mode-specific overrides\n    const pointerModeOverrides = this.pointerOptions[pointerType];\n    if (pointerModeOverrides) {\n      return _extends({}, baseConfig, pointerModeOverrides);\n    }\n    return baseConfig;\n  }\n\n  /**\n   * Handle state change events\n   * @param event Custom event with new state values in the detail property\n   */\n  handleStateChange = event => {\n    if (event && event.detail) {\n      this.updateState(event.detail);\n    }\n  };\n\n  /**\n   * Update the gesture state with new values\n   * @param stateChanges Object containing state properties to update\n   */\n  updateState(stateChanges) {\n    // This is a base implementation - concrete gesture classes should override\n    // to handle specific state updates based on their state structure\n    Object.assign(this.state, stateChanges);\n  }\n\n  /**\n   * Create a deep clone of this gesture for a new element\n   *\n   * @param overrides - Optional configuration options that override the defaults\n   * @returns A new instance of this gesture with the same configuration and any overrides applied\n   */\n\n  /**\n   * Check if the event's target is or is contained within any of our registered elements\n   *\n   * @param event - The browser event to check\n   * @returns The matching element or null if no match is found\n   */\n  getTargetElement(event) {\n    if (this.isActive || this.element === event.target || 'contains' in this.element && this.element.contains(event.target) || 'getRootNode' in this.element && this.element.getRootNode() instanceof ShadowRoot && event.composedPath().includes(this.element)) {\n      return this.element;\n    }\n    return null;\n  }\n\n  /** Whether the gesture is currently active */\n  set isActive(isActive) {\n    if (isActive) {\n      this.gesturesRegistry.registerActiveGesture(this.element, this);\n    } else {\n      this.gesturesRegistry.unregisterActiveGesture(this.element, this);\n    }\n  }\n\n  /** Whether the gesture is currently active */\n  get isActive() {\n    return this.gesturesRegistry.isGestureActive(this.element, this) ?? false;\n  }\n\n  /**\n   * Checks if this gesture should be prevented from activating.\n   *\n   * @param element - The DOM element to check against\n   * @param pointerType - The type of pointer triggering the gesture\n   * @returns true if the gesture should be prevented, false otherwise\n   */\n  shouldPreventGesture(element, pointerType) {\n    // Get effective configuration for this pointer type\n    const effectiveConfig = this.getEffectiveConfig(pointerType, this.getBaseConfig());\n\n    // First check if required keyboard keys are pressed\n    if (!this.keyboardManager.areKeysPressed(effectiveConfig.requiredKeys)) {\n      return true; // Prevent the gesture if required keys are not pressed\n    }\n    if (this.preventIf.length === 0) {\n      return false; // No prevention rules, allow the gesture\n    }\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Check if any of the gestures that would prevent this one are active\n    return this.preventIf.some(gestureName => activeGestures[gestureName]);\n  }\n\n  /**\n   * Checks if the given pointer type is allowed for this gesture based on the pointerMode setting.\n   *\n   * @param pointerType - The type of pointer to check.\n   * @returns true if the pointer type is allowed, false otherwise.\n   */\n  isPointerTypeAllowed(pointerType) {\n    // If no pointer mode is specified, all pointer types are allowed\n    if (!this.pointerMode || this.pointerMode.length === 0) {\n      return true;\n    }\n\n    // Check if the pointer type is in the allowed types list\n    return this.pointerMode.includes(pointerType);\n  }\n\n  /**\n   * Clean up the gesture and unregister any listeners\n   * Call this method when the gesture is no longer needed to prevent memory leaks\n   */\n  destroy() {\n    const changeOptionsEventName = `${this.name}ChangeOptions`;\n    this.element.removeEventListener(changeOptionsEventName, this.handleOptionsChange);\n    const changeStateEventName = `${this.name}ChangeState`;\n    this.element.removeEventListener(changeStateEventName, this.handleStateChange);\n  }\n\n  /**\n   * Reset the gesture state to its initial values\n   */\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 925, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/PointerGesture.js"],"sourcesContent":["import { Gesture } from \"./Gesture.js\";\n\n/**\n * Base configuration options that can be overridden per pointer mode.\n */\n\n/**\n * Configuration options for pointer-based gestures, extending the base GestureOptions.\n *\n * These options provide fine-grained control over how pointer events are interpreted\n * and when the gesture should be recognized.\n */\n\n/**\n * Base class for all pointer-based gestures.\n *\n * This class extends the base Gesture class with specialized functionality for\n * handling pointer events via the PointerManager. It provides common logic for\n * determining when a gesture should activate, tracking pointer movements, and\n * managing pointer thresholds.\n *\n * All pointer-based gesture implementations should extend this class rather than\n * the base Gesture class.\n *\n * @example\n * ```ts\n * import { PointerGesture } from './PointerGesture';\n *\n * class CustomGesture extends PointerGesture {\n *   constructor(options) {\n *     super(options);\n *   }\n *\n *   clone(overrides) {\n *     return new CustomGesture({\n *       name: this.name,\n *       // ... other options\n *       ...overrides,\n *     });\n *   }\n *\n *   handlePointerEvent = (pointers, event) => {\n *     // Handle pointer events here\n *   }\n * }\n * ```\n */\nexport class PointerGesture extends Gesture {\n  /** Function to unregister from the PointerManager when destroying this gesture */\n  unregisterHandler = null;\n\n  /** The original target element when the gesture began, used to prevent limbo state if target is removed */\n  originalTarget = null;\n\n  /**\n   * Minimum number of simultaneous pointers required to activate the gesture.\n   * The gesture will not start until at least this many pointers are active.\n   */\n\n  /**\n   * Maximum number of simultaneous pointers allowed for this gesture.\n   * If more than this many pointers are detected, the gesture may be canceled.\n   */\n\n  constructor(options) {\n    super(options);\n    this.minPointers = options.minPointers ?? 1;\n    this.maxPointers = options.maxPointers ?? Infinity;\n  }\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.unregisterHandler = this.pointerManager.registerGestureHandler(this.handlePointerEvent);\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.minPointers = options.minPointers ?? this.minPointers;\n    this.maxPointers = options.maxPointers ?? this.maxPointers;\n  }\n  getBaseConfig() {\n    return {\n      requiredKeys: this.requiredKeys,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers\n    };\n  }\n  isWithinPointerCount(pointers, pointerMode) {\n    const config = this.getEffectiveConfig(pointerMode, this.getBaseConfig());\n    return pointers.length >= config.minPointers && pointers.length <= config.maxPointers;\n  }\n\n  /**\n   * Handler for pointer events from the PointerManager.\n   * Concrete gesture implementations must override this method to provide\n   * gesture-specific logic for recognizing and tracking the gesture.\n   *\n   * @param pointers - Map of active pointers by pointer ID\n   * @param event - The original pointer event from the browser\n   */\n\n  /**\n   * Calculate the target element for the gesture based on the active pointers.\n   *\n   * It takes into account the original target element.\n   *\n   * @param pointers - Map of active pointers by pointer ID\n   * @param calculatedTarget - The target element calculated from getTargetElement\n   * @returns A list of relevant pointers for this gesture\n   */\n  getRelevantPointers(pointers, calculatedTarget) {\n    return pointers.filter(pointer => this.isPointerTypeAllowed(pointer.pointerType) && (calculatedTarget === pointer.target || pointer.target === this.originalTarget || calculatedTarget === this.originalTarget || 'contains' in calculatedTarget && calculatedTarget.contains(pointer.target)) || 'getRootNode' in calculatedTarget && calculatedTarget.getRootNode() instanceof ShadowRoot && pointer.srcEvent.composedPath().includes(calculatedTarget));\n  }\n  destroy() {\n    if (this.unregisterHandler) {\n      this.unregisterHandler();\n      this.unregisterHandler = null;\n    }\n    super.destroy();\n  }\n}"],"names":[],"mappings":";;;;AAAA;;AA+CO,MAAM,uBAAuB,uLAAO;IACzC,gFAAgF,GAChF,oBAAoB,KAAK;IAEzB,yGAAyG,GACzG,iBAAiB,KAAK;IAEtB;;;GAGC,GAED;;;GAGC,GAED,YAAY,OAAO,CAAE;QACnB,KAAK,CAAC;QACN,IAAI,CAAC,WAAW,GAAG,QAAQ,WAAW,IAAI;QAC1C,IAAI,CAAC,WAAW,GAAG,QAAQ,WAAW,IAAI;IAC5C;IACA,KAAK,OAAO,EAAE,cAAc,EAAE,eAAe,EAAE,eAAe,EAAE;QAC9D,KAAK,CAAC,KAAK,SAAS,gBAAgB,iBAAiB;QACrD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,cAAc,CAAC,sBAAsB,CAAC,IAAI,CAAC,kBAAkB;IAC7F;IACA,cAAc,OAAO,EAAE;QACrB,KAAK,CAAC,cAAc;QACpB,IAAI,CAAC,WAAW,GAAG,QAAQ,WAAW,IAAI,IAAI,CAAC,WAAW;QAC1D,IAAI,CAAC,WAAW,GAAG,QAAQ,WAAW,IAAI,IAAI,CAAC,WAAW;IAC5D;IACA,gBAAgB;QACd,OAAO;YACL,cAAc,IAAI,CAAC,YAAY;YAC/B,aAAa,IAAI,CAAC,WAAW;YAC7B,aAAa,IAAI,CAAC,WAAW;QAC/B;IACF;IACA,qBAAqB,QAAQ,EAAE,WAAW,EAAE;QAC1C,MAAM,SAAS,IAAI,CAAC,kBAAkB,CAAC,aAAa,IAAI,CAAC,aAAa;QACtE,OAAO,SAAS,MAAM,IAAI,OAAO,WAAW,IAAI,SAAS,MAAM,IAAI,OAAO,WAAW;IACvF;IAEA;;;;;;;GAOC,GAED;;;;;;;;GAQC,GACD,oBAAoB,QAAQ,EAAE,gBAAgB,EAAE;QAC9C,OAAO,SAAS,MAAM,CAAC,CAAA,UAAW,IAAI,CAAC,oBAAoB,CAAC,QAAQ,WAAW,KAAK,CAAC,qBAAqB,QAAQ,MAAM,IAAI,QAAQ,MAAM,KAAK,IAAI,CAAC,cAAc,IAAI,qBAAqB,IAAI,CAAC,cAAc,IAAI,cAAc,oBAAoB,iBAAiB,QAAQ,CAAC,QAAQ,MAAM,CAAC,KAAK,iBAAiB,oBAAoB,iBAAiB,WAAW,cAAc,cAAc,QAAQ,QAAQ,CAAC,YAAY,GAAG,QAAQ,CAAC;IAC1a;IACA,UAAU;QACR,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC1B,IAAI,CAAC,iBAAiB;YACtB,IAAI,CAAC,iBAAiB,GAAG;QAC3B;QACA,KAAK,CAAC;IACR;AACF","ignoreList":[0]}},
    {"offset": {"line": 995, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/utils/calculateCentroid.js"],"sourcesContent":["/**\n * Calculate the centroid (average position) of multiple pointers\n */\nexport function calculateCentroid(pointers) {\n  if (pointers.length === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const sum = pointers.reduce((acc, pointer) => {\n    acc.x += pointer.clientX;\n    acc.y += pointer.clientY;\n    return acc;\n  }, {\n    x: 0,\n    y: 0\n  });\n  return {\n    x: sum.x / pointers.length,\n    y: sum.y / pointers.length\n  };\n}"],"names":[],"mappings":"AAAA;;CAEC;;;;AACM,SAAS,kBAAkB,QAAQ;IACxC,IAAI,SAAS,MAAM,KAAK,GAAG;QACzB,OAAO;YACL,GAAG;YACH,GAAG;QACL;IACF;IACA,MAAM,MAAM,SAAS,MAAM,CAAC,CAAC,KAAK;QAChC,IAAI,CAAC,IAAI,QAAQ,OAAO;QACxB,IAAI,CAAC,IAAI,QAAQ,OAAO;QACxB,OAAO;IACT,GAAG;QACD,GAAG;QACH,GAAG;IACL;IACA,OAAO;QACL,GAAG,IAAI,CAAC,GAAG,SAAS,MAAM;QAC1B,GAAG,IAAI,CAAC,GAAG,SAAS,MAAM;IAC5B;AACF","ignoreList":[0]}},
    {"offset": {"line": 1025, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/utils/createEventName.js"],"sourcesContent":["/**\n * Creates the event name for a specific gesture and phase\n */\nexport function createEventName(gesture, phase) {\n  return `${gesture}${phase === 'ongoing' ? '' : phase.charAt(0).toUpperCase() + phase.slice(1)}`;\n}"],"names":[],"mappings":"AAAA;;CAEC;;;;AACM,SAAS,gBAAgB,OAAO,EAAE,KAAK;IAC5C,OAAO,GAAG,UAAU,UAAU,YAAY,KAAK,MAAM,MAAM,CAAC,GAAG,WAAW,KAAK,MAAM,KAAK,CAAC,IAAI;AACjG","ignoreList":[0]}},
    {"offset": {"line": 1038, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/gestures/MoveGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * MoveGesture - Detects when a pointer enters, moves within, and leaves an element\n *\n * This gesture tracks pointer movements over an element, firing events when:\n * - A pointer enters the element (start)\n * - A pointer moves within the element (ongoing)\n * - A pointer leaves the element (end)\n *\n * Unlike other gestures which often require specific actions to trigger,\n * the move gesture fires automatically when pointers interact with the target element.\n *\n * This gesture only works with mouse pointers, not touch or pen.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\n\n/**\n * Configuration options for the MoveGesture\n * Extends the base PointerGestureOptions\n */\n\n/**\n * Event data specific to move gesture events\n * Includes the source pointer event and standard gesture data\n */\n\n/**\n * Type definition for the CustomEvent created by MoveGesture\n */\n\n/**\n * State tracking for the MoveGesture\n */\n\n/**\n * MoveGesture class for handling pointer movement over elements\n *\n * This gesture detects when pointers enter, move within, or leave target elements,\n * and dispatches corresponding custom events.\n *\n * This gesture only works with hovering mouse pointers, not touch.\n */\nexport class MoveGesture extends PointerGesture {\n  state = {\n    lastPosition: null\n  };\n\n  /**\n   * Movement threshold in pixels that must be exceeded before the gesture activates.\n   * Higher values reduce false positive gesture detection for small movements.\n   */\n\n  constructor(options) {\n    super(options);\n    this.threshold = options.threshold || 0;\n  }\n  clone(overrides) {\n    return new MoveGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      threshold: this.threshold,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\n\n    // Add event listeners for entering and leaving elements\n    // These are different from pointer events handled by PointerManager\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener('pointerenter', this.handleElementEnter);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener('pointerleave', this.handleElementLeave);\n  }\n  destroy() {\n    // Remove event listeners using the same function references\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener('pointerenter', this.handleElementEnter);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener('pointerleave', this.handleElementLeave);\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    // Call parent method to handle common options\n    super.updateOptions(options);\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = {\n      lastPosition: null\n    };\n  }\n\n  /**\n   * Handle pointer enter events for a specific element\n   * @param event The original pointer event\n   */\n  handleElementEnter = event => {\n    if (event.pointerType !== 'mouse' && event.pointerType !== 'pen') {\n      return;\n    }\n\n    // Get pointers from the PointerManager\n    const pointers = this.pointerManager.getPointers() || new Map();\n    const pointersArray = Array.from(pointers.values());\n\n    // Only activate if we're within pointer count constraints\n    if (this.isWithinPointerCount(pointersArray, event.pointerType)) {\n      this.isActive = true;\n      const currentPosition = {\n        x: event.clientX,\n        y: event.clientY\n      };\n      this.state.lastPosition = currentPosition;\n\n      // Emit start event\n      this.emitMoveEvent(this.element, 'start', pointersArray, event);\n      this.emitMoveEvent(this.element, 'ongoing', pointersArray, event);\n    }\n  };\n\n  /**\n   * Handle pointer leave events for a specific element\n   * @param event The original pointer event\n   */\n  handleElementLeave = event => {\n    if (event.pointerType !== 'mouse' && event.pointerType !== 'pen') {\n      return;\n    }\n    if (!this.isActive) {\n      return;\n    }\n\n    // Get pointers from the PointerManager\n    const pointers = this.pointerManager.getPointers() || new Map();\n    const pointersArray = Array.from(pointers.values());\n\n    // Emit end event and reset state\n    this.emitMoveEvent(this.element, 'end', pointersArray, event);\n    this.resetState();\n  };\n\n  /**\n   * Handle pointer events for the move gesture (only handles move events now)\n   * @param pointers Map of active pointers\n   * @param event The original pointer event\n   */\n  handlePointerEvent = (pointers, event) => {\n    if (event.type !== 'pointermove' || event.pointerType !== 'mouse' && event.pointerType !== 'pen') {\n      return;\n    }\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n    const pointersArray = Array.from(pointers.values());\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n    if (!this.isWithinPointerCount(pointersArray, event.pointerType)) {\n      return;\n    }\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      if (!this.isActive) {\n        return;\n      }\n      this.resetState();\n      this.emitMoveEvent(targetElement, 'end', pointersArray, event);\n      return;\n    }\n\n    // Update position\n    const currentPosition = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    this.state.lastPosition = currentPosition;\n    if (!this.isActive) {\n      this.isActive = true;\n      this.emitMoveEvent(targetElement, 'start', pointersArray, event);\n    }\n    // Emit ongoing event\n    this.emitMoveEvent(targetElement, 'ongoing', pointersArray, event);\n  };\n\n  /**\n   * Emit move-specific events\n   * @param element The DOM element the event is related to\n   * @param phase The current phase of the gesture (start, ongoing, end)\n   * @param pointers Array of active pointers\n   * @param event The original pointer event\n   */\n  emitMoveEvent(element, phase, pointers, event) {\n    const currentPosition = this.state.lastPosition || calculateCentroid(pointers);\n\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Create custom event data\n    const customEventData = {\n      gestureName: this.name,\n      centroid: currentPosition,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1242, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/utils/getDirection.js"],"sourcesContent":["const MAIN_THRESHOLD = 0.00001;\nconst ANGLE_THRESHOLD = 0.00001;\nconst SECONDARY_THRESHOLD = 0.15;\n\n/**\n * Get the direction of movement based on the current and previous positions\n */\nexport function getDirection(previous, current) {\n  const deltaX = current.x - previous.x;\n  const deltaY = current.y - previous.y;\n  const direction = {\n    vertical: null,\n    horizontal: null,\n    mainAxis: null\n  };\n  const isDiagonal = isDiagonalMovement(current, previous);\n  const mainMovement = Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical';\n\n  // eslint-disable-next-line no-nested-ternary\n  const horizontalThreshold = isDiagonal ? MAIN_THRESHOLD : mainMovement === 'horizontal' ? MAIN_THRESHOLD : SECONDARY_THRESHOLD;\n  // eslint-disable-next-line no-nested-ternary\n  const verticalThreshold = isDiagonal ? MAIN_THRESHOLD : mainMovement === 'horizontal' ? SECONDARY_THRESHOLD : MAIN_THRESHOLD;\n\n  // Set horizontal direction if there's a significant movement horizontally\n  if (Math.abs(deltaX) > horizontalThreshold) {\n    // Small threshold to avoid noise\n    direction.horizontal = deltaX > 0 ? 'right' : 'left';\n  }\n\n  // Set vertical direction if there's a significant movement vertically\n  if (Math.abs(deltaY) > verticalThreshold) {\n    // Small threshold to avoid noise\n    direction.vertical = deltaY > 0 ? 'down' : 'up';\n  }\n  direction.mainAxis = isDiagonal ? 'diagonal' : mainMovement;\n  return direction;\n}\nfunction isDiagonalMovement(previous, current) {\n  const deltaX = current.x - previous.x;\n  const deltaY = current.y - previous.y;\n\n  // Calculate the angle of movement\n  const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;\n\n  // Check if the angle is within the diagonal range\n  return angle >= -45 + ANGLE_THRESHOLD && angle <= -22.5 + ANGLE_THRESHOLD || angle >= 22.5 + ANGLE_THRESHOLD && angle <= 45 + ANGLE_THRESHOLD || angle >= 135 + ANGLE_THRESHOLD && angle <= 157.5 + ANGLE_THRESHOLD || angle >= -157.5 + ANGLE_THRESHOLD && angle <= -135 + ANGLE_THRESHOLD;\n}"],"names":[],"mappings":";;;;AAAA,MAAM,iBAAiB;AACvB,MAAM,kBAAkB;AACxB,MAAM,sBAAsB;AAKrB,SAAS,aAAa,QAAQ,EAAE,OAAO;IAC5C,MAAM,SAAS,QAAQ,CAAC,GAAG,SAAS,CAAC;IACrC,MAAM,SAAS,QAAQ,CAAC,GAAG,SAAS,CAAC;IACrC,MAAM,YAAY;QAChB,UAAU;QACV,YAAY;QACZ,UAAU;IACZ;IACA,MAAM,aAAa,mBAAmB,SAAS;IAC/C,MAAM,eAAe,KAAK,GAAG,CAAC,UAAU,KAAK,GAAG,CAAC,UAAU,eAAe;IAE1E,6CAA6C;IAC7C,MAAM,sBAAsB,aAAa,iBAAiB,iBAAiB,eAAe,iBAAiB;IAC3G,6CAA6C;IAC7C,MAAM,oBAAoB,aAAa,iBAAiB,iBAAiB,eAAe,sBAAsB;IAE9G,0EAA0E;IAC1E,IAAI,KAAK,GAAG,CAAC,UAAU,qBAAqB;QAC1C,iCAAiC;QACjC,UAAU,UAAU,GAAG,SAAS,IAAI,UAAU;IAChD;IAEA,sEAAsE;IACtE,IAAI,KAAK,GAAG,CAAC,UAAU,mBAAmB;QACxC,iCAAiC;QACjC,UAAU,QAAQ,GAAG,SAAS,IAAI,SAAS;IAC7C;IACA,UAAU,QAAQ,GAAG,aAAa,aAAa;IAC/C,OAAO;AACT;AACA,SAAS,mBAAmB,QAAQ,EAAE,OAAO;IAC3C,MAAM,SAAS,QAAQ,CAAC,GAAG,SAAS,CAAC;IACrC,MAAM,SAAS,QAAQ,CAAC,GAAG,SAAS,CAAC;IAErC,kCAAkC;IAClC,MAAM,QAAQ,KAAK,KAAK,CAAC,QAAQ,UAAU,MAAM,KAAK,EAAE;IAExD,kDAAkD;IAClD,OAAO,SAAS,CAAC,KAAK,mBAAmB,SAAS,CAAC,OAAO,mBAAmB,SAAS,OAAO,mBAAmB,SAAS,KAAK,mBAAmB,SAAS,MAAM,mBAAmB,SAAS,QAAQ,mBAAmB,SAAS,CAAC,QAAQ,mBAAmB,SAAS,CAAC,MAAM;AAC9Q","ignoreList":[0]}},
    {"offset": {"line": 1288, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/utils/isDirectionAllowed.js"],"sourcesContent":["/**\n * Check if a direction matches one of the allowed directions\n */\nexport function isDirectionAllowed(direction, allowedDirections) {\n  if (!direction.vertical && !direction.horizontal) {\n    return false;\n  }\n  if (allowedDirections.length === 0) {\n    return true;\n  }\n\n  // Check if the vertical direction is allowed (if it exists)\n  const verticalAllowed = direction.vertical === null || allowedDirections.includes(direction.vertical);\n\n  // Check if the horizontal direction is allowed (if it exists)\n  const horizontalAllowed = direction.horizontal === null || allowedDirections.includes(direction.horizontal);\n\n  // Both directions must be allowed\n  return verticalAllowed && horizontalAllowed;\n}"],"names":[],"mappings":"AAAA;;CAEC;;;;AACM,SAAS,mBAAmB,SAAS,EAAE,iBAAiB;IAC7D,IAAI,CAAC,UAAU,QAAQ,IAAI,CAAC,UAAU,UAAU,EAAE;QAChD,OAAO;IACT;IACA,IAAI,kBAAkB,MAAM,KAAK,GAAG;QAClC,OAAO;IACT;IAEA,4DAA4D;IAC5D,MAAM,kBAAkB,UAAU,QAAQ,KAAK,QAAQ,kBAAkB,QAAQ,CAAC,UAAU,QAAQ;IAEpG,8DAA8D;IAC9D,MAAM,oBAAoB,UAAU,UAAU,KAAK,QAAQ,kBAAkB,QAAQ,CAAC,UAAU,UAAU;IAE1G,kCAAkC;IAClC,OAAO,mBAAmB;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 1312, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/gestures/PanGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PanGesture - Detects panning (dragging) movements\n *\n * This gesture tracks pointer dragging movements across elements, firing events when:\n * - The drag movement begins and passes the threshold distance (start)\n * - The drag movement continues (ongoing)\n * - The drag movement ends (end)\n *\n * The gesture can be configured to recognize movement only in specific directions.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, createEventName, getDirection, isDirectionAllowed } from \"../utils/index.js\";\n\n/**\n * Configuration options for PanGesture\n * Extends PointerGestureOptions with direction constraints\n */\n\n/**\n * Event data specific to pan gesture events\n * Contains information about movement distance, direction, and velocity\n */\n\n/**\n * Type definition for the CustomEvent created by PanGesture\n */\n\n/**\n * State tracking for the PanGesture\n */\n\n/**\n * PanGesture class for handling panning/dragging interactions\n *\n * This gesture detects when users drag across elements with one or more pointers,\n * and dispatches directional movement events with delta and velocity information.\n */\nexport class PanGesture extends PointerGesture {\n  state = (() => ({\n    startPointers: new Map(),\n    startCentroid: null,\n    lastCentroid: null,\n    movementThresholdReached: false,\n    totalDeltaX: 0,\n    totalDeltaY: 0,\n    activeDeltaX: 0,\n    activeDeltaY: 0,\n    lastDirection: {\n      vertical: null,\n      horizontal: null,\n      mainAxis: null\n    },\n    lastDeltas: null\n  }))();\n\n  /**\n   * Movement threshold in pixels that must be exceeded before the gesture activates.\n   * Higher values reduce false positive gesture detection for small movements.\n   */\n\n  /**\n   * Allowed directions for the pan gesture\n   * Default allows all directions\n   */\n\n  constructor(options) {\n    super(options);\n    this.direction = options.direction || ['up', 'down', 'left', 'right'];\n    this.threshold = options.threshold || 0;\n  }\n  clone(overrides) {\n    return new PanGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      threshold: this.threshold,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      direction: [...this.direction],\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.direction = options.direction || this.direction;\n    this.threshold = options.threshold ?? this.threshold;\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = _extends({}, this.state, {\n      startPointers: new Map(),\n      startCentroid: null,\n      lastCentroid: null,\n      lastDeltas: null,\n      activeDeltaX: 0,\n      activeDeltaY: 0,\n      movementThresholdReached: false,\n      lastDirection: {\n        vertical: null,\n        horizontal: null,\n        mainAxis: null\n      }\n    });\n  }\n\n  /**\n   * Handle pointer events for the pan gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Check for our forceCancel event to handle interrupted gestures (from contextmenu, blur)\n    if (event.type === 'forceCancel') {\n      // Reset all active pan gestures when we get a force reset event\n      this.cancel(event.target, pointersArray, event);\n      return;\n    }\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      // If the gesture was active but now should be prevented, cancel it gracefully\n      this.cancel(targetElement, pointersArray, event);\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n      // Cancel or end the gesture if it was active\n      this.cancel(targetElement, relevantPointers, event);\n      return;\n    }\n    switch (event.type) {\n      case 'pointerdown':\n        if (!this.isActive && !this.state.startCentroid) {\n          // Store initial pointers\n          relevantPointers.forEach(pointer => {\n            this.state.startPointers.set(pointer.pointerId, pointer);\n          });\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n\n          // Calculate and store the starting centroid\n          this.state.startCentroid = calculateCentroid(relevantPointers);\n          this.state.lastCentroid = _extends({}, this.state.startCentroid);\n        }\n        break;\n      case 'pointermove':\n        if (this.state.startCentroid && this.isWithinPointerCount(pointersArray, event.pointerType)) {\n          // Calculate current centroid\n          const currentCentroid = calculateCentroid(relevantPointers);\n\n          // Calculate delta from start\n          const distanceDeltaX = currentCentroid.x - this.state.startCentroid.x;\n          const distanceDeltaY = currentCentroid.y - this.state.startCentroid.y;\n\n          // Calculate movement distance\n          const distance = Math.sqrt(distanceDeltaX * distanceDeltaX + distanceDeltaY * distanceDeltaY);\n\n          // Determine movement direction\n          const moveDirection = getDirection(this.state.lastCentroid ?? this.state.startCentroid, currentCentroid);\n\n          // Calculate change in position since last move\n          const lastDeltaX = this.state.lastCentroid ? currentCentroid.x - this.state.lastCentroid.x : 0;\n          const lastDeltaY = this.state.lastCentroid ? currentCentroid.y - this.state.lastCentroid.y : 0;\n\n          // Check if movement passes the threshold and is in an allowed direction\n          if (!this.state.movementThresholdReached && distance >= this.threshold && isDirectionAllowed(moveDirection, this.direction)) {\n            this.state.movementThresholdReached = true;\n            this.isActive = true;\n\n            // Update total accumulated delta\n            this.state.lastDeltas = {\n              x: lastDeltaX,\n              y: lastDeltaY\n            };\n            this.state.totalDeltaX += lastDeltaX;\n            this.state.totalDeltaY += lastDeltaY;\n            this.state.activeDeltaX += lastDeltaX;\n            this.state.activeDeltaY += lastDeltaY;\n\n            // Emit start event\n            this.emitPanEvent(targetElement, 'start', relevantPointers, event, currentCentroid);\n            this.emitPanEvent(targetElement, 'ongoing', relevantPointers, event, currentCentroid);\n          }\n          // If we've already crossed the threshold, continue tracking\n          else if (this.state.movementThresholdReached && this.isActive) {\n            // Update total accumulated delta\n            this.state.lastDeltas = {\n              x: lastDeltaX,\n              y: lastDeltaY\n            };\n            this.state.totalDeltaX += lastDeltaX;\n            this.state.totalDeltaY += lastDeltaY;\n            this.state.activeDeltaX += lastDeltaX;\n            this.state.activeDeltaY += lastDeltaY;\n\n            // Emit ongoing event\n            this.emitPanEvent(targetElement, 'ongoing', relevantPointers, event, currentCentroid);\n          }\n\n          // Update last centroid\n          this.state.lastCentroid = currentCentroid;\n          this.state.lastDirection = moveDirection;\n        }\n        break;\n      case 'pointerup':\n      case 'pointercancel':\n      case 'forceCancel':\n        // If the gesture was active (threshold was reached), emit end event\n        if (this.isActive && this.state.movementThresholdReached) {\n          const remainingPointers = relevantPointers.filter(p => p.type !== 'pointerup' && p.type !== 'pointercancel');\n\n          // If we no longer meet the pointer count requirements, end the gesture\n          if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {\n            // End the gesture\n            const currentCentroid = this.state.lastCentroid || this.state.startCentroid;\n            if (event.type === 'pointercancel') {\n              this.emitPanEvent(targetElement, 'cancel', relevantPointers, event, currentCentroid);\n            }\n            this.emitPanEvent(targetElement, 'end', relevantPointers, event, currentCentroid);\n            this.resetState();\n          }\n        } else {\n          this.resetState();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Emit pan-specific events with additional data\n   */\n  emitPanEvent(element, phase, pointers, event, currentCentroid) {\n    if (!this.state.startCentroid) {\n      return;\n    }\n    const deltaX = this.state.lastDeltas?.x ?? 0;\n    const deltaY = this.state.lastDeltas?.y ?? 0;\n\n    // Calculate velocity - time difference in seconds\n    const firstPointer = this.state.startPointers.values().next().value;\n    const timeElapsed = firstPointer ? (event.timeStamp - firstPointer.timeStamp) / 1000 : 0;\n    const velocityX = timeElapsed > 0 ? deltaX / timeElapsed : 0;\n    const velocityY = timeElapsed > 0 ? deltaY / timeElapsed : 0;\n    const velocity = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Create custom event data\n    const customEventData = {\n      gestureName: this.name,\n      initialCentroid: this.state.startCentroid,\n      centroid: currentCentroid,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      deltaX,\n      deltaY,\n      direction: this.state.lastDirection,\n      velocityX,\n      velocityY,\n      velocity,\n      totalDeltaX: this.state.totalDeltaX,\n      totalDeltaY: this.state.totalDeltaY,\n      activeDeltaX: this.state.activeDeltaX,\n      activeDeltaY: this.state.activeDeltaY,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n\n    // Apply preventDefault/stopPropagation if configured\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Cancel the current gesture\n   */\n  cancel(element, pointers, event) {\n    if (this.isActive) {\n      const el = element ?? this.element;\n      this.emitPanEvent(el, 'cancel', pointers, event, this.state.lastCentroid);\n      this.emitPanEvent(el, 'end', pointers, event, this.state.lastCentroid);\n    }\n    this.resetState();\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1602, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/utils/getDistance.js"],"sourcesContent":["/**\n * Calculate the distance between two points\n */\nexport function getDistance(pointA, pointB) {\n  const deltaX = pointB.x - pointA.x;\n  const deltaY = pointB.y - pointA.y;\n  return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n}"],"names":[],"mappings":"AAAA;;CAEC;;;;AACM,SAAS,YAAY,MAAM,EAAE,MAAM;IACxC,MAAM,SAAS,OAAO,CAAC,GAAG,OAAO,CAAC;IAClC,MAAM,SAAS,OAAO,CAAC,GAAG,OAAO,CAAC;IAClC,OAAO,KAAK,IAAI,CAAC,SAAS,SAAS,SAAS;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 1617, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/utils/calculateAverageDistance.js"],"sourcesContent":["import { getDistance } from \"./getDistance.js\";\n\n/**\n * Calculate the average distance between all pairs of pointers\n */\nexport function calculateAverageDistance(pointers) {\n  if (pointers.length < 2) {\n    return 0;\n  }\n  let totalDistance = 0;\n  let pairCount = 0;\n\n  // Calculate distance between each pair of pointers\n  for (let i = 0; i < pointers.length; i += 1) {\n    for (let j = i + 1; j < pointers.length; j += 1) {\n      totalDistance += getDistance({\n        x: pointers[i].clientX,\n        y: pointers[i].clientY\n      }, {\n        x: pointers[j].clientX,\n        y: pointers[j].clientY\n      });\n      pairCount += 1;\n    }\n  }\n\n  // Return average distance\n  return pairCount > 0 ? totalDistance / pairCount : 0;\n}"],"names":[],"mappings":";;;;AAAA;;AAKO,SAAS,yBAAyB,QAAQ;IAC/C,IAAI,SAAS,MAAM,GAAG,GAAG;QACvB,OAAO;IACT;IACA,IAAI,gBAAgB;IACpB,IAAI,YAAY;IAEhB,mDAAmD;IACnD,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,KAAK,EAAG;QAC3C,IAAK,IAAI,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,KAAK,EAAG;YAC/C,iBAAiB,IAAA,wMAAW,EAAC;gBAC3B,GAAG,QAAQ,CAAC,EAAE,CAAC,OAAO;gBACtB,GAAG,QAAQ,CAAC,EAAE,CAAC,OAAO;YACxB,GAAG;gBACD,GAAG,QAAQ,CAAC,EAAE,CAAC,OAAO;gBACtB,GAAG,QAAQ,CAAC,EAAE,CAAC,OAAO;YACxB;YACA,aAAa;QACf;IACF;IAEA,0BAA0B;IAC1B,OAAO,YAAY,IAAI,gBAAgB,YAAY;AACrD","ignoreList":[0]}},
    {"offset": {"line": 1649, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/utils/getPinchDirection.js"],"sourcesContent":["const DIRECTION_THRESHOLD = 0;\nexport const getPinchDirection = velocity => {\n  if (velocity > DIRECTION_THRESHOLD) {\n    return 1; // Zooming in\n  }\n  if (velocity < -DIRECTION_THRESHOLD) {\n    return -1; // Zooming out\n  }\n  return 0; // No significant movement\n};"],"names":[],"mappings":";;;;AAAA,MAAM,sBAAsB;AACrB,MAAM,oBAAoB,CAAA;IAC/B,IAAI,WAAW,qBAAqB;QAClC,OAAO,GAAG,aAAa;IACzB;IACA,IAAI,WAAW,CAAC,qBAAqB;QACnC,OAAO,CAAC,GAAG,cAAc;IAC3B;IACA,OAAO,GAAG,0BAA0B;AACtC","ignoreList":[0]}},
    {"offset": {"line": 1667, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/gestures/PinchGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PinchGesture - Detects pinch (zoom) movements with two or more pointers\n *\n * This gesture tracks when multiple pointers move toward or away from each other, firing events when:\n * - Two or more pointers begin moving (start)\n * - The pointers continue changing distance (ongoing)\n * - One or more pointers are released or lifted (end)\n *\n * This gesture is commonly used to implement zoom functionality in touch interfaces.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateAverageDistance, calculateCentroid, createEventName, getPinchDirection } from \"../utils/index.js\";\n\n/**\n * Configuration options for the PinchGesture\n * Uses the same options as the base PointerGesture\n */\n\n/**\n * Event data specific to pinch gesture events\n * Contains information about scale, distance, and velocity\n */\n\n/**\n * Type definition for the CustomEvent created by PinchGesture\n */\n\n/**\n * State tracking for the PinchGesture\n */\n\n/**\n * PinchGesture class for handling pinch/zoom interactions\n *\n * This gesture detects when users move multiple pointers toward or away from each other,\n * and dispatches scale-related events with distance and velocity information.\n */\nexport class PinchGesture extends PointerGesture {\n  state = {\n    startDistance: 0,\n    lastDistance: 0,\n    lastScale: 1,\n    lastTime: 0,\n    velocity: 0,\n    totalScale: 1,\n    deltaScale: 0\n  };\n\n  /**\n   * Movement threshold in pixels that must be exceeded before the gesture activates.\n   * Higher values reduce false positive gesture detection for small movements.\n   */\n\n  constructor(options) {\n    super(_extends({}, options, {\n      minPointers: options.minPointers ?? 2\n    }));\n    this.threshold = options.threshold ?? 0;\n  }\n  clone(overrides) {\n    return new PinchGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      threshold: this.threshold,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = _extends({}, this.state, {\n      startDistance: 0,\n      lastDistance: 0,\n      lastScale: 1,\n      lastTime: 0,\n      velocity: 0,\n      deltaScale: 0\n    });\n  }\n\n  /**\n   * Handle pointer events for the pinch gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      if (this.isActive) {\n        // If the gesture was active but now should be prevented, end it gracefully\n        this.emitPinchEvent(targetElement, 'cancel', pointersArray, event);\n        this.resetState();\n      }\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    switch (event.type) {\n      case 'pointerdown':\n        if (relevantPointers.length >= 2 && !this.isActive) {\n          // Calculate and store the starting distance between pointers\n          const initialDistance = calculateAverageDistance(relevantPointers);\n          this.state.startDistance = initialDistance;\n          this.state.lastDistance = initialDistance;\n          this.state.lastTime = event.timeStamp;\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n        }\n        break;\n      case 'pointermove':\n        if (this.state.startDistance && this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n          // Calculate current distance between pointers\n          const currentDistance = calculateAverageDistance(relevantPointers);\n\n          // Calculate absolute distance change\n          const distanceChange = Math.abs(currentDistance - this.state.lastDistance);\n\n          // Only proceed if the distance between pointers has changed enough\n          if (distanceChange !== 0 && distanceChange >= this.threshold) {\n            // Calculate scale relative to starting distance\n            const scale = this.state.startDistance ? currentDistance / this.state.startDistance : 1;\n\n            // Calculate the relative scale change since last event\n            const scaleChange = scale / this.state.lastScale;\n            // Apply this change to the total accumulated scale\n            this.state.totalScale *= scaleChange;\n            // Calculate velocity (change in scale over time)\n            const deltaTime = (event.timeStamp - this.state.lastTime) / 1000; // convert to seconds\n            if (this.state.lastDistance) {\n              const deltaDistance = currentDistance - this.state.lastDistance;\n              const result = deltaDistance / deltaTime;\n              this.state.velocity = Number.isNaN(result) ? 0 : result;\n            }\n\n            // Update state\n            this.state.lastDistance = currentDistance;\n            this.state.deltaScale = scale - this.state.lastScale;\n            this.state.lastScale = scale;\n            this.state.lastTime = event.timeStamp;\n            if (!this.isActive) {\n              // Mark gesture as active\n              this.isActive = true;\n\n              // Emit start event\n              this.emitPinchEvent(targetElement, 'start', relevantPointers, event);\n              this.emitPinchEvent(targetElement, 'ongoing', relevantPointers, event);\n            } else {\n              // Emit ongoing event\n              this.emitPinchEvent(targetElement, 'ongoing', relevantPointers, event);\n            }\n          }\n        }\n        break;\n      case 'pointerup':\n      case 'pointercancel':\n      case 'forceCancel':\n        if (this.isActive) {\n          const remainingPointers = relevantPointers.filter(p => p.type !== 'pointerup' && p.type !== 'pointercancel');\n\n          // If we no longer meet the pointer count requirements, end the gesture\n          if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {\n            if (event.type === 'pointercancel') {\n              this.emitPinchEvent(targetElement, 'cancel', relevantPointers, event);\n            }\n            this.emitPinchEvent(targetElement, 'end', relevantPointers, event);\n\n            // Reset state\n            this.resetState();\n          } else if (remainingPointers.length >= 2) {\n            // If we still have enough pointers, update the start distance\n            // to prevent jumping when a finger is lifted\n            const newDistance = calculateAverageDistance(remainingPointers);\n            this.state.startDistance = newDistance / this.state.lastScale;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Emit pinch-specific events with additional data\n   */\n  emitPinchEvent(element, phase, pointers, event) {\n    // Calculate current centroid\n    const centroid = calculateCentroid(pointers);\n\n    // Create custom event data\n    const distance = this.state.lastDistance;\n    const scale = this.state.lastScale;\n\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n    const customEventData = {\n      gestureName: this.name,\n      centroid,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      scale,\n      deltaScale: this.state.deltaScale,\n      totalScale: this.state.totalScale,\n      distance,\n      velocity: this.state.velocity,\n      activeGestures,\n      direction: getPinchDirection(this.state.velocity),\n      customData: this.customData\n    };\n\n    // Handle default event behavior\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1892, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/utils/preventDefault.js"],"sourcesContent":["export const preventDefault = event => {\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n};"],"names":[],"mappings":";;;;AAAO,MAAM,iBAAiB,CAAA;IAC5B,IAAI,MAAM,UAAU,EAAE;QACpB,MAAM,cAAc;IACtB;AACF","ignoreList":[0]}},
    {"offset": {"line": 1905, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/gestures/PressGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PressGesture - Detects press and hold interactions\n *\n * This gesture tracks when users press and hold on an element for a specified duration, firing events when:\n * - The press begins and passes the holding threshold time (start, ongoing)\n * - The press ends (end)\n * - The press is canceled by movement beyond threshold (cancel)\n *\n * This gesture is commonly used for contextual menus, revealing additional options, or alternate actions.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\n\n/**\n * Configuration options for PressGesture\n * Extends PointerGestureOptions with press-specific options\n */\n\n/**\n * Event data specific to press gesture events\n * Contains information about the press location and duration\n */\n\n/**\n * Type definition for the CustomEvent created by PressGesture\n */\n\n/**\n * State tracking for the PressGesture\n */\n\n/**\n * PressGesture class for handling press/hold interactions\n *\n * This gesture detects when users press and hold on an element for a specified duration,\n * and dispatches press-related events when the user holds long enough.\n *\n * The `start` and `ongoing` events are dispatched at the same time once the press threshold is reached.\n * If the press is canceled (event.g., by moving too far), a `cancel` event is dispatched before the `end` event.\n */\nexport class PressGesture extends PointerGesture {\n  state = {\n    startCentroid: null,\n    lastPosition: null,\n    timerId: null,\n    startTime: 0,\n    pressThresholdReached: false\n  };\n\n  /**\n   * Duration in milliseconds required to hold before the press gesture is recognized\n   */\n\n  /**\n   * Maximum distance a pointer can move for a gesture to still be considered a press\n   */\n\n  constructor(options) {\n    super(options);\n    this.duration = options.duration ?? 500;\n    this.maxDistance = options.maxDistance ?? 10;\n  }\n  clone(overrides) {\n    return new PressGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      duration: this.duration,\n      maxDistance: this.maxDistance,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.clearPressTimer();\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.duration = options.duration ?? this.duration;\n    this.maxDistance = options.maxDistance ?? this.maxDistance;\n  }\n  resetState() {\n    this.clearPressTimer();\n    this.isActive = false;\n    this.state = _extends({}, this.state, {\n      startCentroid: null,\n      lastPosition: null,\n      timerId: null,\n      startTime: 0,\n      pressThresholdReached: false\n    });\n  }\n\n  /**\n   * Clear the press timer if it's active\n   */\n  clearPressTimer() {\n    if (this.state.timerId !== null) {\n      clearTimeout(this.state.timerId);\n      this.state.timerId = null;\n    }\n  }\n\n  /**\n   * Handle pointer events for the press gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Check for our forceCancel event to handle interrupted gestures (from contextmenu, blur)\n    if (event.type === 'forceCancel') {\n      // Reset all active press gestures when we get a force reset event\n      this.cancelPress(event.target, pointersArray, event);\n      return;\n    }\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      if (this.isActive) {\n        // If the gesture was active but now should be prevented, cancel it gracefully\n        this.cancelPress(targetElement, pointersArray, event);\n      }\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n      if (this.isActive) {\n        // Cancel or end the gesture if it was active\n        this.cancelPress(targetElement, relevantPointers, event);\n      }\n      return;\n    }\n    switch (event.type) {\n      case 'pointerdown':\n        if (!this.isActive && !this.state.startCentroid) {\n          // Calculate and store the starting centroid\n          this.state.startCentroid = calculateCentroid(relevantPointers);\n          this.state.lastPosition = _extends({}, this.state.startCentroid);\n          this.state.startTime = event.timeStamp;\n          this.isActive = true;\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n\n          // Start the timer for press recognition\n          this.clearPressTimer(); // Clear any existing timer first\n          this.state.timerId = setTimeout(() => {\n            if (this.isActive && this.state.startCentroid) {\n              this.state.pressThresholdReached = true;\n              const lastPosition = this.state.lastPosition;\n\n              // Emit press start event\n              this.emitPressEvent(targetElement, 'start', relevantPointers, event, lastPosition);\n              this.emitPressEvent(targetElement, 'ongoing', relevantPointers, event, lastPosition);\n            }\n          }, this.duration);\n        }\n        break;\n      case 'pointermove':\n        if (this.isActive && this.state.startCentroid) {\n          // Calculate current position\n          const currentPosition = calculateCentroid(relevantPointers);\n          this.state.lastPosition = currentPosition;\n\n          // Calculate distance from start position\n          const deltaX = currentPosition.x - this.state.startCentroid.x;\n          const deltaY = currentPosition.y - this.state.startCentroid.y;\n          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n          // If moved too far, cancel the press gesture\n          if (distance > this.maxDistance) {\n            this.cancelPress(targetElement, relevantPointers, event);\n          }\n        }\n        break;\n      case 'pointerup':\n        if (this.isActive) {\n          if (this.state.pressThresholdReached) {\n            // Complete the press gesture if we've held long enough\n            const position = this.state.lastPosition || this.state.startCentroid;\n            this.emitPressEvent(targetElement, 'end', relevantPointers, event, position);\n          }\n\n          // Reset state\n          this.resetState();\n        }\n        break;\n      case 'pointercancel':\n      case 'forceCancel':\n        // Cancel the gesture\n        this.cancelPress(targetElement, relevantPointers, event);\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Emit press-specific events with additional data\n   */\n  emitPressEvent(element, phase, pointers, event, position) {\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Calculate current duration of the press\n    const currentDuration = event.timeStamp - this.state.startTime;\n\n    // Create custom event data\n    const customEventData = {\n      gestureName: this.name,\n      centroid: position,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      x: position.x,\n      y: position.y,\n      duration: currentDuration,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n\n    // Apply preventDefault/stopPropagation if configured\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Cancel the current press gesture\n   */\n  cancelPress(element, pointers, event) {\n    if (this.isActive && this.state.pressThresholdReached) {\n      const position = this.state.lastPosition || this.state.startCentroid;\n      this.emitPressEvent(element ?? this.element, 'cancel', pointers, event, position);\n      this.emitPressEvent(element ?? this.element, 'end', pointers, event, position);\n    }\n    this.resetState();\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2137, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/gestures/PressAndDragGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PressAndDragGesture - Detects press followed by drag gestures using composition\n *\n * This gesture uses internal PressGesture and PanGesture instances to:\n * 1. First, detect a press (hold for specified duration without movement)\n * 2. Then, track drag movements from the press position\n *\n * The gesture fires events when:\n * - A press is completed (press phase)\n * - Drag movement begins and passes threshold (dragStart)\n * - Drag movement continues (drag)\n * - Drag movement ends (dragEnd)\n * - The gesture is canceled at any point\n *\n * This is ideal for panning operations where you want to hold first, then drag.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { createEventName, preventDefault } from \"../utils/index.js\";\nimport { PanGesture } from \"./PanGesture.js\";\nimport { PressGesture } from \"./PressGesture.js\";\n\n/**\n * Configuration options for PressAndDragGesture\n * Extends PointerGestureOptions with press and drag specific settings\n */\n\n/**\n * Event data specific to press and drag gesture events\n * Contains information about the gesture state, position, and movement\n */\n\n/**\n * Type definition for the CustomEvent created by PressAndDragGesture\n */\n\n/**\n * Represents the current phase of the PressAndDrag gesture\n */\n\n/**\n * State tracking for the PressAndDragGesture\n */\n\n/**\n * PressAndDragGesture class for handling press followed by drag interactions\n *\n * This gesture composes press and drag logic patterns from PressGesture and PanGesture\n * into a single coordinated gesture that handles press-then-drag interactions.\n */\nexport class PressAndDragGesture extends PointerGesture {\n  state = {\n    phase: 'waitingForPress',\n    dragTimeoutId: null\n  };\n\n  /**\n   * Duration required for press recognition\n   */\n\n  /**\n   * Maximum distance a pointer can move during press for it to still be considered a press\n   */\n\n  /**\n   * Maximum time between press completion and drag start\n   */\n\n  /**\n   * Movement threshold for drag activation\n   */\n\n  /**\n   * Allowed directions for the drag gesture\n   */\n\n  constructor(options) {\n    super(options);\n    this.pressDuration = options.pressDuration ?? 500;\n    this.pressMaxDistance = options.pressMaxDistance ?? 10;\n    this.dragTimeout = options.dragTimeout ?? 1000;\n    this.dragThreshold = options.dragThreshold ?? 0;\n    this.dragDirection = options.dragDirection || ['up', 'down', 'left', 'right'];\n    this.pressGesture = new PressGesture({\n      name: `${this.name}-press`,\n      duration: this.pressDuration,\n      maxDistance: this.pressMaxDistance,\n      maxPointers: this.maxPointers,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n    this.panGesture = new PanGesture({\n      name: `${this.name}-pan`,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      threshold: this.dragThreshold,\n      direction: this.dragDirection,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n  }\n  clone(overrides) {\n    return new PressAndDragGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      pressDuration: this.pressDuration,\n      pressMaxDistance: this.pressMaxDistance,\n      dragTimeout: this.dragTimeout,\n      dragThreshold: this.dragThreshold,\n      dragDirection: [...this.dragDirection],\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.pressGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.panGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n\n    // Listen to press gesture events\n    this.element.addEventListener(this.pressGesture.name, this.pressHandler);\n\n    // Listen to pan gesture events for dragging\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n  }\n  destroy() {\n    this.resetState();\n    this.pressGesture.destroy();\n    this.panGesture.destroy();\n    this.element.removeEventListener(this.pressGesture.name, this.pressHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.pressDuration = options.pressDuration ?? this.pressDuration;\n    this.pressMaxDistance = options.pressMaxDistance ?? this.pressMaxDistance;\n    this.dragTimeout = options.dragTimeout ?? this.dragTimeout;\n    this.dragThreshold = options.dragThreshold ?? this.dragThreshold;\n    this.dragDirection = options.dragDirection || this.dragDirection;\n\n    // Update internal gesture options\n    this.element.dispatchEvent(new CustomEvent(`${this.panGesture.name}ChangeOptions`, {\n      detail: {\n        minPointers: this.minPointers,\n        maxPointers: this.maxPointers,\n        threshold: this.dragThreshold,\n        direction: this.dragDirection,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n    this.element.dispatchEvent(new CustomEvent(`${this.pressGesture.name}ChangeOptions`, {\n      detail: {\n        duration: this.pressDuration,\n        maxDistance: this.pressMaxDistance,\n        maxPointers: this.maxPointers,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n  }\n  resetState() {\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n    }\n    this.restoreTouchAction();\n    this.isActive = false;\n    this.state = {\n      phase: 'waitingForPress',\n      dragTimeoutId: null\n    };\n  }\n\n  /**\n   * This can be empty because the PressAndDragGesture relies on PressGesture and PanGesture to handle pointer events\n   * The internal gestures will manage their own state and events, while this class coordinates between them\n   */\n  handlePointerEvent() {}\n  pressHandler = () => {\n    if (this.state.phase !== 'waitingForPress') {\n      return;\n    }\n    this.state.phase = 'pressDetected';\n    this.setTouchAction();\n\n    // Start timeout to wait for drag start\n    this.state.dragTimeoutId = setTimeout(() => {\n      // Timeout expired, reset gesture\n      this.resetState();\n    }, this.dragTimeout);\n  };\n  dragStartHandler = event => {\n    if (this.state.phase !== 'pressDetected') {\n      return;\n    }\n\n    // Clear the drag timeout as drag has started\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n      this.state.dragTimeoutId = null;\n    }\n\n    // Restore touch action since we're now dragging\n    this.restoreTouchAction();\n    this.state.phase = 'dragging';\n    this.isActive = true;\n\n    // Fire start event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragMoveHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n\n    // Fire move event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragEndHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n    this.resetState();\n\n    // Fire end event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  setTouchAction() {\n    this.element.addEventListener('touchstart', preventDefault, {\n      passive: false\n    });\n    this.element.addEventListener('touchmove', preventDefault, {\n      passive: false\n    });\n    this.element.addEventListener('touchend', preventDefault, {\n      passive: false\n    });\n  }\n  restoreTouchAction() {\n    this.element.removeEventListener('touchstart', preventDefault);\n    this.element.removeEventListener('touchmove', preventDefault);\n    this.element.removeEventListener('touchend', preventDefault);\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2384, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/gestures/TapGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * TapGesture - Detects tap (quick touch without movement) gestures\n *\n * This gesture tracks simple tap interactions on elements, firing a single event when:\n * - A complete tap is detected (pointerup after brief touch without excessive movement)\n * - The tap is canceled (event.g., moved too far or held too long)\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\n\n/**\n * Configuration options for TapGesture\n * Extends PointerGestureOptions with tap-specific settings\n */\n\n/**\n * Event data specific to tap gesture events\n * Contains information about the tap location and counts\n */\n\n/**\n * Type definition for the CustomEvent created by TapGesture\n */\n\n/**\n * State tracking for the TapGesture\n */\n\n/**\n * TapGesture class for handling tap interactions\n *\n * This gesture detects when users tap on elements without significant movement,\n * and can recognize single taps, double taps, or other multi-tap sequences.\n */\nexport class TapGesture extends PointerGesture {\n  state = {\n    startCentroid: null,\n    currentTapCount: 0,\n    lastTapTime: 0,\n    lastPosition: null\n  };\n\n  /**\n   * Maximum distance a pointer can move for a gesture to still be considered a tap\n   */\n\n  /**\n   * Number of consecutive taps to detect\n   */\n\n  constructor(options) {\n    super(options);\n    this.maxDistance = options.maxDistance ?? 10;\n    this.taps = options.taps ?? 1;\n  }\n  clone(overrides) {\n    return new TapGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      maxDistance: this.maxDistance,\n      taps: this.taps,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.maxDistance = options.maxDistance ?? this.maxDistance;\n    this.taps = options.taps ?? this.taps;\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = {\n      startCentroid: null,\n      currentTapCount: 0,\n      lastTapTime: 0,\n      lastPosition: null\n    };\n  }\n\n  /**\n   * Handle pointer events for the tap gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    if (this.shouldPreventGesture(targetElement, event.pointerType) || !this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n      if (this.isActive) {\n        // Cancel the gesture if it was active\n        this.cancelTap(targetElement, relevantPointers, event);\n      }\n      return;\n    }\n    switch (event.type) {\n      case 'pointerdown':\n        if (!this.isActive) {\n          // Calculate and store the starting centroid\n          this.state.startCentroid = calculateCentroid(relevantPointers);\n          this.state.lastPosition = _extends({}, this.state.startCentroid);\n          this.isActive = true;\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n        }\n        break;\n      case 'pointermove':\n        if (this.isActive && this.state.startCentroid) {\n          // Calculate current position\n          const currentPosition = calculateCentroid(relevantPointers);\n          this.state.lastPosition = currentPosition;\n\n          // Calculate distance from start position\n          const deltaX = currentPosition.x - this.state.startCentroid.x;\n          const deltaY = currentPosition.y - this.state.startCentroid.y;\n          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n          // If moved too far, cancel the tap gesture\n          if (distance > this.maxDistance) {\n            this.cancelTap(targetElement, relevantPointers, event);\n          }\n        }\n        break;\n      case 'pointerup':\n        if (this.isActive) {\n          // For valid tap: increment tap count\n          this.state.currentTapCount += 1;\n\n          // Make sure we have a valid position before firing the tap event\n          const position = this.state.lastPosition || this.state.startCentroid;\n          if (!position) {\n            this.cancelTap(targetElement, relevantPointers, event);\n            return;\n          }\n\n          // Check if we've reached the desired number of taps\n          if (this.state.currentTapCount >= this.taps) {\n            // The complete tap sequence has been detected - fire the tap event\n            this.fireTapEvent(targetElement, relevantPointers, event, position);\n\n            // Reset state after successful tap\n            this.resetState();\n          } else {\n            // Store the time of this tap for multi-tap detection\n            this.state.lastTapTime = event.timeStamp;\n\n            // Reset active state but keep the tap count for multi-tap detection\n            this.isActive = false;\n\n            // For multi-tap detection: keep track of the last tap position\n            // but clear the start centroid to prepare for next tap\n            this.state.startCentroid = null;\n\n            // Start a timeout to reset the tap count if the next tap doesn't come soon enough\n            setTimeout(() => {\n              if (this.state && this.state.currentTapCount > 0 && this.state.currentTapCount < this.taps) {\n                this.state.currentTapCount = 0;\n              }\n            }, 300); // 300ms is a typical double-tap detection window\n          }\n        }\n        break;\n      case 'pointercancel':\n      case 'forceCancel':\n        // Cancel the gesture\n        this.cancelTap(targetElement, relevantPointers, event);\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Fire the main tap event when a valid tap is detected\n   */\n  fireTapEvent(element, pointers, event, position) {\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Create custom event data for the tap event\n    const customEventData = {\n      gestureName: this.name,\n      centroid: position,\n      target: event.target,\n      srcEvent: event,\n      phase: 'end',\n      // The tap is complete, so we use 'end' state for the event data\n      pointers,\n      timeStamp: event.timeStamp,\n      x: position.x,\n      y: position.y,\n      tapCount: this.state.currentTapCount,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Dispatch a single 'tap' event (not 'tapStart', 'tapEnd', etc.)\n    const domEvent = new CustomEvent(this.name, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n\n    // Apply preventDefault/stopPropagation if configured\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Cancel the current tap gesture\n   */\n  cancelTap(element, pointers, event) {\n    if (this.state.startCentroid || this.state.lastPosition) {\n      const position = this.state.lastPosition || this.state.startCentroid;\n\n      // Get list of active gestures\n      const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n      // Create custom event data for the cancel event\n      const customEventData = {\n        gestureName: this.name,\n        centroid: position,\n        target: event.target,\n        srcEvent: event,\n        phase: 'cancel',\n        pointers,\n        timeStamp: event.timeStamp,\n        x: position.x,\n        y: position.y,\n        tapCount: this.state.currentTapCount,\n        activeGestures,\n        customData: this.customData\n      };\n\n      // Dispatch a 'tapCancel' event\n      const eventName = createEventName(this.name, 'cancel');\n      const domEvent = new CustomEvent(eventName, {\n        bubbles: true,\n        cancelable: true,\n        composed: true,\n        detail: customEventData\n      });\n      element.dispatchEvent(domEvent);\n    }\n    this.resetState();\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2618, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/gestures/TapAndDragGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * TapAndDragGesture - Detects tap followed by drag gestures using composition\n *\n * This gesture uses internal TapGesture and PanGesture instances to:\n * 1. First, detect a tap (quick touch without movement)\n * 2. Then, track drag movements on the next pointer down\n *\n * The gesture fires events when:\n * - A tap is completed (tap phase)\n * - Drag movement begins and passes threshold (dragStart)\n * - Drag movement continues (drag)\n * - Drag movement ends (dragEnd)\n * - The gesture is canceled at any point\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { createEventName, preventDefault } from \"../utils/index.js\";\nimport { PanGesture } from \"./PanGesture.js\";\nimport { TapGesture } from \"./TapGesture.js\";\n\n/**\n * Configuration options for TapAndDragGesture\n * Extends PointerGestureOptions with tap and drag specific settings\n */\n\n/**\n * Event data specific to tap and drag gesture events\n * Contains information about the gesture state, position, and movement\n */\n\n/**\n * Type definition for the CustomEvent created by TapAndDragGesture\n */\n\n/**\n * Represents the current phase of the TapAndDrag gesture\n */\n\n/**\n * State tracking for the TapAndDragGesture\n */\n\n/**\n * TapAndDragGesture class for handling tap followed by drag interactions\n *\n * This gesture composes tap and drag logic patterns from TapGesture and PanGesture\n * into a single coordinated gesture that handles tap-then-drag interactions.\n */\nexport class TapAndDragGesture extends PointerGesture {\n  state = {\n    phase: 'waitingForTap',\n    dragTimeoutId: null\n  };\n\n  /**\n   * Maximum distance a pointer can move during tap for it to still be considered a tap\n   * (Following TapGesture pattern)\n   */\n\n  /**\n   * Maximum time between tap completion and drag start\n   */\n\n  /**\n   * Movement threshold for drag activation\n   */\n\n  /**\n   * Allowed directions for the drag gesture\n   */\n\n  constructor(options) {\n    super(options);\n    this.tapMaxDistance = options.tapMaxDistance ?? 10;\n    this.dragTimeout = options.dragTimeout ?? 1000;\n    this.dragThreshold = options.dragThreshold ?? 0;\n    this.dragDirection = options.dragDirection || ['up', 'down', 'left', 'right'];\n    this.tapGesture = new TapGesture({\n      name: `${this.name}-tap`,\n      maxDistance: this.tapMaxDistance,\n      maxPointers: this.maxPointers,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n    this.panGesture = new PanGesture({\n      name: `${this.name}-pan`,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      threshold: this.dragThreshold,\n      direction: this.dragDirection,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n  }\n  clone(overrides) {\n    return new TapAndDragGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      tapMaxDistance: this.tapMaxDistance,\n      dragTimeout: this.dragTimeout,\n      dragThreshold: this.dragThreshold,\n      dragDirection: [...this.dragDirection],\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.tapGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.panGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.element.addEventListener(this.tapGesture.name, this.tapHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n  }\n  destroy() {\n    this.resetState();\n    this.tapGesture.destroy();\n    this.panGesture.destroy();\n    this.element.removeEventListener(this.tapGesture.name, this.tapHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.tapMaxDistance = options.tapMaxDistance ?? this.tapMaxDistance;\n    this.dragTimeout = options.dragTimeout ?? this.dragTimeout;\n    this.dragThreshold = options.dragThreshold ?? this.dragThreshold;\n    this.dragDirection = options.dragDirection || this.dragDirection;\n    this.element.dispatchEvent(new CustomEvent(`${this.panGesture.name}ChangeOptions`, {\n      detail: {\n        minPointers: this.minPointers,\n        maxPointers: this.maxPointers,\n        threshold: this.dragThreshold,\n        direction: this.dragDirection,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n    this.element.dispatchEvent(new CustomEvent(`${this.tapGesture.name}ChangeOptions`, {\n      detail: {\n        maxDistance: this.tapMaxDistance,\n        maxPointers: this.maxPointers,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n  }\n  resetState() {\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n    }\n    this.restoreTouchAction();\n    this.isActive = false;\n    this.state = {\n      phase: 'waitingForTap',\n      dragTimeoutId: null\n    };\n  }\n\n  /**\n   * This can be empty because the TapAndDragGesture relies on TapGesture and PanGesture to handle pointer events\n   * The internal gestures will manage their own state and events, while this class coordinates between them\n   */\n  handlePointerEvent() {}\n  tapHandler = () => {\n    if (this.state.phase !== 'waitingForTap') {\n      return;\n    }\n    this.state.phase = 'tapDetected';\n    this.setTouchAction();\n\n    // Start timeout to wait for drag start\n    this.state.dragTimeoutId = setTimeout(() => {\n      // Timeout expired, reset gesture\n      this.resetState();\n    }, this.dragTimeout);\n  };\n  dragStartHandler = event => {\n    if (this.state.phase !== 'tapDetected') {\n      return;\n    }\n\n    // Clear the drag timeout as drag has started\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n      this.state.dragTimeoutId = null;\n    }\n    this.restoreTouchAction();\n    this.state.phase = 'dragging';\n    this.isActive = true;\n\n    // Fire start event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragMoveHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n\n    // Fire move event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragEndHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n    this.resetState();\n\n    // Fire end event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  setTouchAction() {\n    this.element.addEventListener('touchstart', preventDefault, {\n      passive: false\n    });\n  }\n  restoreTouchAction() {\n    this.element.removeEventListener('touchstart', preventDefault);\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2845, "column": 0}, "map": {"version":3,"sources":["file:///Users/chid/Desktop/RWA-Assignment/node_modules/%40mui/x-internal-gestures/esm/core/gestures/TurnWheelGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * TurnWheelGesture - Detects wheel events on an element\n *\n * This gesture tracks mouse wheel or touchpad scroll events on elements, firing events when:\n * - The user scrolls/wheels on the element (ongoing)\n *\n * Unlike other gestures which may have start/ongoing/end states,\n * wheel gestures are always considered \"ongoing\" since they are discrete events.\n */\n\nimport { Gesture } from \"../Gesture.js\";\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\n\n/**\n * Configuration options for the TurnWheelGesture\n * Uses the base gesture options with additional wheel-specific options\n */\n\n/**\n * Event data specific to wheel gesture events\n * Contains information about scroll delta amounts and mode\n */\n\n/**\n * Type definition for the CustomEvent created by TurnWheelGesture\n */\n\n/**\n * State tracking for the TurnWheelGesture\n */\n\n/**\n * TurnWheelGesture class for handling wheel/scroll interactions\n *\n * This gesture detects when users scroll or use the mouse wheel on elements,\n * and dispatches corresponding scroll events with delta information.\n * Unlike most gestures, it extends directly from Gesture rather than PointerGesture.\n */\nexport class TurnWheelGesture extends Gesture {\n  state = {\n    totalDeltaX: 0,\n    totalDeltaY: 0,\n    totalDeltaZ: 0\n  };\n\n  /**\n   * Scaling factor for delta values\n   * Values > 1 increase sensitivity, values < 1 decrease sensitivity\n   */\n\n  /**\n   * Maximum value for totalDelta values\n   * Limits how large the accumulated wheel deltas can be\n   */\n\n  /**\n   * Minimum value for totalDelta values\n   * Sets a lower bound for accumulated wheel deltas\n   */\n\n  /**\n   * Initial value for totalDelta values\n   * Sets the starting value for delta trackers\n   */\n\n  /**\n   * Whether to invert the direction of delta changes\n   * When true, reverses the sign of deltaX, deltaY, and deltaZ values\n   */\n\n  constructor(options) {\n    super(options);\n    this.sensitivity = options.sensitivity ?? 1;\n    this.max = options.max ?? Number.MAX_SAFE_INTEGER;\n    this.min = options.min ?? Number.MIN_SAFE_INTEGER;\n    this.initialDelta = options.initialDelta ?? 0;\n    this.invert = options.invert ?? false;\n    this.state.totalDeltaX = this.initialDelta;\n    this.state.totalDeltaY = this.initialDelta;\n    this.state.totalDeltaZ = this.initialDelta;\n  }\n  clone(overrides) {\n    return new TurnWheelGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      sensitivity: this.sensitivity,\n      max: this.max,\n      min: this.min,\n      initialDelta: this.initialDelta,\n      invert: this.invert,\n      requiredKeys: [...this.requiredKeys],\n      preventIf: [...this.preventIf]\n    }, overrides));\n  }\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\n\n    // Add event listener directly to the element\n    // @ts-expect-error, WheelEvent is correct.\n    this.element.addEventListener('wheel', this.handleWheelEvent);\n  }\n  destroy() {\n    // Remove the element-specific event listener\n    // @ts-expect-error, WheelEvent is correct.\n    this.element.removeEventListener('wheel', this.handleWheelEvent);\n    this.resetState();\n    super.destroy();\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = {\n      totalDeltaX: 0,\n      totalDeltaY: 0,\n      totalDeltaZ: 0\n    };\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.sensitivity = options.sensitivity ?? this.sensitivity;\n    this.max = options.max ?? this.max;\n    this.min = options.min ?? this.min;\n    this.initialDelta = options.initialDelta ?? this.initialDelta;\n    this.invert = options.invert ?? this.invert;\n  }\n\n  /**\n   * Handle wheel events for a specific element\n   * @param element The element that received the wheel event\n   * @param event The original wheel event\n   */\n  handleWheelEvent = event => {\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(this.element, 'mouse')) {\n      return;\n    }\n\n    // Get pointers from the PointerManager to use for centroid calculation\n    const pointers = this.pointerManager.getPointers() || new Map();\n    const pointersArray = Array.from(pointers.values());\n\n    // Update total deltas with scaled values\n    this.state.totalDeltaX += event.deltaX * this.sensitivity * (this.invert ? -1 : 1);\n    this.state.totalDeltaY += event.deltaY * this.sensitivity * (this.invert ? -1 : 1);\n    this.state.totalDeltaZ += event.deltaZ * this.sensitivity * (this.invert ? -1 : 1);\n\n    // Apply proper min/max clamping for each axis\n    // Ensure values stay between min and max bounds\n    ['totalDeltaX', 'totalDeltaY', 'totalDeltaZ'].forEach(axis => {\n      // First clamp at the minimum bound\n      if (this.state[axis] < this.min) {\n        this.state[axis] = this.min;\n      }\n\n      // Then clamp at the maximum bound\n      if (this.state[axis] > this.max) {\n        this.state[axis] = this.max;\n      }\n    });\n\n    // Emit the wheel event\n    this.emitWheelEvent(pointersArray, event);\n  };\n\n  /**\n   * Emit wheel-specific events\n   * @param pointers The current pointers on the element\n   * @param event The original wheel event\n   */\n  emitWheelEvent(pointers, event) {\n    // Calculate centroid - either from existing pointers or from the wheel event position\n    const centroid = pointers.length > 0 ? calculateCentroid(pointers) : {\n      x: event.clientX,\n      y: event.clientY\n    };\n\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(this.element);\n\n    // Create custom event data\n    const customEventData = {\n      gestureName: this.name,\n      centroid,\n      target: event.target,\n      srcEvent: event,\n      phase: 'ongoing',\n      // Wheel events are always in \"ongoing\" state\n      pointers,\n      timeStamp: event.timeStamp,\n      deltaX: event.deltaX * this.sensitivity * (this.invert ? -1 : 1),\n      deltaY: event.deltaY * this.sensitivity * (this.invert ? -1 : 1),\n      deltaZ: event.deltaZ * this.sensitivity * (this.invert ? -1 : 1),\n      deltaMode: event.deltaMode,\n      totalDeltaX: this.state.totalDeltaX,\n      totalDeltaY: this.state.totalDeltaY,\n      totalDeltaZ: this.state.totalDeltaZ,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Apply default event behavior if configured\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, 'ongoing');\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    this.element.dispatchEvent(domEvent);\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0]}}]
}